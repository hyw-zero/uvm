<!DOCTYPE HTML >
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>svt_mem_core Class Reference</title>
<link href="svdoc.css" rel="stylesheet" type="text/css">
<link href="svdoctabs.css" rel="stylesheet" type="text/css">
<link href="dashboard.css" rel="stylesheet" type="text/css">
<script src="advancedsearch.js"></script>
<script src="GeneralUtility.js"></script>
<script src="PCFiltering.js"></script>
</head><body>
<!-- Generated by svdoc O-2018.09 -->
<div class="tabs"><ul>
  <li><a href="index.html" TITLE = "About this product"><span>Main&nbsp;Page</span></a></li>
  <li id="current"><a href="classhierarchy.html" TITLE = "List of all classes showing the parent/child relationship"><span>Classes</span></a></li>
  <li><a href="macros.html" TITLE = "Alphabetical listing of macros"><span>Macros</span></a></li>
  <li><a href="level1_covergroups.html" TITLE = "Coverage"><span>Coverage</span></a></li>
  <li><a href="protocolChecks.html" TITLE = "List of Protocol Checks defined in VIP"><span>Protocol&nbsp;Checks</span></a></li>
  <li><a href="sequencepages.html" TITLE = "List of Sequences"><span>Sequences</span></a></li>
  <li><a href="interfaces.html" TITLE = "List of Interfaces"><span>Interfaces</span></a></li>
  <li><a href="globals.html" TITLE = "Global members"><span>Globals</span></a></li>
  <li><a href="indexall.html" TITLE = "Complete Index of all Source Code Elements"><span>Index</span></a></li>
  <li><a href="help.html" TITLE = "Help"><span>?</span></a></li>
  <li><form action="javascript:SearchFunction(form.searchtext.value, '', form.searchmode.value)"><table border="0"><tr>
    <td><input NAME="searchbtn" TYPE=button VALUE=" Search " onChange="SearchFunction(form.searchtext.value, '', form.searchmode.value)"></td>
    <td><input NAME="searchtext" TYPE=text VALUE="" onChange="SearchFunction(form.searchtext.value, '', form.searchmode.value)"></td>
    <td><select NAME="searchmode" TYPE=text >
          <option value=simple>simple</option>
          <option value=regexpr>reg expr</option>
    </select></td>
  </tr></table></form></li>
</ul></div>
<div class="tabs"><ul>
  <li><a href="classhierarchy.html" TITLE = "List of all classes showing the parent/child relationship"><span>Hierarchy</span></a></li>
  <li><a href="classlist.html" TITLE = "List of all classes"><span>Class&nbsp;List</span></a></li>
  <li><a href="classalphalist.html" TITLE = "Alphabetical listing of classes"><span>Alphabetical&nbsp;List</span></a></li>
  <li><a href="suite_classhierarchy.html" TITLE = "Suite specific list of all classes showing the parent/child relationship"><span>Transactor&nbsp;Class&nbsp;Hierarchy</span></a></li>
</ul></div>
<h1>svt_mem_core Class Reference</h1>
<p>Inheritance diagram for class svt_mem_core:</p>
 <input id="toggle_svt_mem_core" value="+" onclick=toggleDiv("hdiv_svt_mem_core","toggle_svt_mem_core") title="svt_mem_core class inheritence diagram" type="button"/><div id="hdiv_svt_mem_core" style="display:none;"><p><center><img src="svt_mem_core.png" USEMAP="#svt_mem_core" border="0" alt=""> </center>
</div><map id="svt_mem_core" name="svt_mem_core">
<area shape="rect" id="node1" href="class_uvm_void.html" title="uvm_void" alt="" coords="52,5,129,35"/>
<area shape="rect" id="node2" href="class_uvm_object.html" title="uvm_object" alt="" coords="47,83,135,112"/>
<area shape="rect" id="node4" href="class_uvm_transaction.html" title="uvm_transaction" alt="" coords="32,160,149,189"/>
<area shape="rect" id="node6" href="class_uvm_sequence_item.html" title="uvm_sequence_item" alt="" coords="20,237,161,267"/>
<area shape="rect" id="node10" href="class_svt_mem_core.html" title="svt_mem_core" alt="" coords="35,393,147,423"/>
</map>
<p><a href="class_svt_mem_core-members.html">List of all members.</a>
<hr>
<a name="_details"></a><h2>Detailed Description</h2>
<p>
This class is the SystemVerilog class which contains the C core. It provides the
 SystemVerilog API through which the C-based memory core can be manipulated.
</p>
<hr>

<table border="0" cellpadding="0" cellspacing="0">

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_compare_base">compare_base</a>&nbsp;(
string filename , svt_mem_backdoor_base :: compare_type_enum compare_type , int max_errors , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , <b>svt_mem_address_mapper</b> mapper  = null  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_dump_base">dump_base</a>&nbsp;(
string filename , string filetype , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , <b>svt_mem_address_mapper</b> mapper  = null, int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_end_access">end_access</a>&nbsp;(
svt_mem_addr_t addr , svt_mem_addr_t burst_size  = 1  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_free">free</a>&nbsp;(
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_free_all">free_all</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_get_addr_width">get_addr_width</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;<a class="ClassLink" href="class_svt_mem_backdoor.html#item_svt_mem_backdoor">svt_mem_backdoor</a>&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_get_backdoor">get_backdoor</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;unsigned int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_get_checks">get_checks</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_get_data_width">get_data_width</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_get_is_4state">get_is_4state</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_initialize">initialize</a>&nbsp;(
svt_mem_backdoor_base :: init_pattern_type_enum pattern  = INIT_CONST, svt_mem_data_t base_data  = 0, svt_mem_addr_t start_addr  = 0, svt_mem_addr_t end_addr  = -1  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_load_base">load_base</a>&nbsp;(
string filename , <b>svt_mem_address_mapper</b> mapper  = null, int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_new">new</a>&nbsp;(
<a class="ClassLink" href="class_svt_mem_configuration.html">svt_mem_configuration</a> cfg , <a class="ClassLink" href="class_uvm_report_object.html">uvm_report_object</a> reporter   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_protect">protect</a>&nbsp;(
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_reconfigure">reconfigure</a>&nbsp;(
<a class="ClassLink" href="class_svt_configuration.html">svt_configuration</a> cfg   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_reset">reset</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_set_checks">set_checks</a>&nbsp;(
int unsigned enables   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_start_access">start_access</a>&nbsp;(
bit mode , svt_mem_addr_t addr , svt_mem_addr_t burst_size  = 1  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_unprotect">unprotect</a>&nbsp;(
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi   )</td>
</tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">static string&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_file_data_object_uids">file_data_object_uids</a> [ int ][$]&nbsp;</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">static <a class="ClassLink" href="class_svt_mem_core.html">svt_mem_core</a>&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_core.html#item_svt_mem_core_ids">svt_mem_core_ids</a> [ int ]&nbsp;</td>
</tr>
</table>
<p>
<hr>
<h2 class="pre20">Member Function Documentation</h2>
<div style="margin-left: 0px; margin->right: 0px">
<a class="anchor" name="item_compare_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_core::<b>compare_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
string filename , svt_mem_backdoor_base :: compare_type_enum compare_type , int max_errors , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , <b>svt_mem_address_mapper</b> mapper  = null      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Internal method for comparing the content of the memory in the specifed
 address range (entire memory by default) with the data found in the specifed file,
 using the relevant policy based on the filename.

<p>
 The 'mapper' can be used to convert between the source address domain used in
 the file and the destination address domain used by the backdoor. If the 'mapper'
 is not provided it implies the source and destination address domains are the
 same.

<p>
 The following comparison mode are available:

<p>

<ul><li>
 Subset: The content of the file is present in the memory core. The 
 memory core may contain additional values that are ignored.

</li><li>
 Strict: The content of the file is strictly equal to the content of the
 memory core.

</li><li>
 Superset: The content of the memory core is present in the file. The
 file may contain additional values that are ignored.

</li><li>
 Intersect: The same addresses present in the memory core and in the
 file contain the same data. Addresses present only in the file or the
 memory core are ignored.

</li></ul>


<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_compare_base">filename</a></b> -  Name of the file to compare to. The file extension
 determines which format the file is created in.
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_compare_base">compare_type</a></b> -  Determines which kind of compare is executed
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_compare_base">max_errors</a></b> -  Data comparison terminates after reaching max_errors. If
 max_errors is 0 assume a maximum error count of 10.
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_compare_base">addr_lo</a></b> -  Starting address
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_compare_base">addr_hi</a></b> -  Ending address

<p>
 <p><b>Return values - </b>  The number of miscompares.
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>compare_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_dump_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>dump_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
string filename , string filetype , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , <b>svt_mem_address_mapper</b> mapper  = null, int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Internal method for saving memory contents within the indicated 'addr_lo' to
 'addr_hi' address range into the specified 'file' using the format identified
 by 'filetype', where the only supported values are "MIF" and "MEMH".

<p>
 The 'mapper' can be used to convert between the source address domain used in
 the file and the destination address domain used by the backdoor. If the 'mapper'
 is not provided it implies the source and destination address domains are the
 same.

<p>
 The 'modes' field is a loophole for conveying basic well defined instructions
 to the backdoor implementations.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_dump_base">filename</a></b> -  Name of the file to write to. The file extension
 determines which format the file is created in.
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_dump_base">filetype</a></b> -  The string name of the format to be used when writing a
 memory dump file, either "MIF" or "MEMH".
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_dump_base">addr_lo</a></b> -  Starting address
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_dump_base">addr_hi</a></b> -  Ending address
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_dump_base">mapper</a></b> -  Used to convert between address domains.
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_dump_base">modes</a></b> -  Optional dump modes, represented by individual constants. Supported values:

<ul><li>
 SVT_MEM_DUMP_ALL - Specify in order to include 'all' addresses in the output. 

</li><li>
 SVT_MEM_DUMP_NO_HEADER - To exclude the header at the front of the file.

</li><li>
 SVT_MEM_DUMP_NO_BEGIN - To exclude the BEGIN at the start of the data block (MIF).

</li><li>
 SVT_MEM_DUMP_NO_END - To exclude the END at the end of the data block (MIF).

</li><li>
 SVT_MEM_DUMP_APPEND - Append the contents to the existing file if found.

</li></ul>

</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>dump_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_end_access"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>end_access</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr , svt_mem_addr_t burst_size  = 1      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Ends an access lock.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_end_access">addr</a></b> -  specific address to be cleared.
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_end_access">burst_size</a></b> -  number of addresses to be cleared.
</div></td></tr>
</table>
<a class="anchor" name="item_free"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_core::<b>free</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Flush the content of the memory in the speicified address range.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_free">addr_lo</a></b> -  low addr address
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_free">addr_hi</a></b> -  high addr address
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>free</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_free_all"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>free_all</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Flush the entire content of the memory. Alias for <a class="ClassLink" href="class_svt_mem_core.html#item_reset">reset</a>. 
</div></td></tr>
</table>
<a class="anchor" name="item_get_addr_width"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_core::<b>get_addr_width</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Returns memcore address width. 
</div></td></tr>
</table>
<a class="anchor" name="item_get_backdoor"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function <a class="ClassLink" href="class_svt_mem_backdoor.html#item_svt_mem_backdoor">svt_mem_backdoor</a><br>&nbsp;svt_mem_core::<b>get_backdoor</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Return a new instance of a svt_mem_backdoor class. 
</div></td></tr>
</table>
<a class="anchor" name="item_get_checks"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function unsigned int<br>&nbsp;svt_mem_core::<b>get_checks</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Retrieves the check mask which determines which checks the memserver performs 

<p>
 Retrieves the check mask which determines which checks the C-based memserver
 application performs. The return value is a bitwise-OR that determines which
 checks are enabled.

<p>
 The following macros can be used to test whether specific checks are enabled:
 <ul>
 <li>`SVT_MEM_SA_CHECK_RD_RD_NO_WR - two reads to the same location with no intervening write.</li>
 <li>`SVT_MEM_SA_CHECK_WR_LOSS - two writes with no intervening read and the second write altered the data of that location.</li>
 <li>`SVT_MEM_SA_CHECK_WR_SAME - a location was re-written with the same data it already held</li>
 <li>`SVT_MEM_SA_CHECK_WR_WR - two writes with no intervening read.</li>
 <li>`SVT_MEM_SA_CHECK_RD_B4_WR - a location was read before it was initialized or written.</li>
 <li>`SVT_MEM_SA_CHECK_WR_PROT - a write was attempted to a write protected instance or to a write protected location.</li>
 <li>`SVT_MEM_SA_CHECK_ADR_ERR - an address is beyond the specified address width of an instance or address range error.</li>
 <li>`SVT_MEM_SA_CHECK_DATA_ERR - a data value exceeded the specified data width in bits.</li>
 <li>`SVT_MEM_SA_CHECK_ACCESS_LOCKED - a backdoor access (peek or poke) was attempted to a location within an active access-locked memory range.</li>
 <li>`SVT_MEM_SA_CHECK_ACCESS_ERROR - a read or write or start_access or end_access was attempted to a location within an active access-locked memory range.</li>
 <li>`SVT_MEM_SA_CHECK_PARTIAL_RD - a read was made from a location where only some bits had been initialized. Only applies to 4-state instances.</li>
 </ul>
</div></td></tr>
</table>
<a class="anchor" name="item_get_data_width"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_core::<b>get_data_width</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Returns memcore data width. 
</div></td></tr>
</table>
<a class="anchor" name="item_get_is_4state"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_core::<b>get_is_4state</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Returns memcore 2state/4state 
</div></td></tr>
</table>
<a class="anchor" name="item_initialize"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>initialize</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_backdoor_base :: init_pattern_type_enum pattern  = INIT_CONST, svt_mem_data_t base_data  = 0, svt_mem_addr_t start_addr  = 0, svt_mem_addr_t end_addr  = -1      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Initialize the specified address range in the memory with the specified
 pattern. Supported patterns are: constant value, incrementing values,
 decrementing values, walk left, walk right. For user-defined patterns, the
 backdoor should be used.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_initialize">pattern</a></b> -  initialization pattern.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_initialize">base_data</a></b> -  Starting data value used with each pattern

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_initialize">start_addr</a></b> -  start address of the region to be initialized.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_initialize">end_addr</a></b> -  end address of the region to be initilized.
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>initialize</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_load_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>load_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
string filename , <b>svt_mem_address_mapper</b> mapper  = null, int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Internal method for loading memory locations with the contents of the specified
 file.

<p>
 The 'mapper' can be used to convert between the source address domain used in the
 file and the destination address domain used by the backdoor. If the 'mapper' is
 not provided it implies the source and destination address domains are the same.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_load_base">filename</a></b> -  Name of the file to load. The file extension determines
 which format to expect.
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_load_base">mapper</a></b> -  Used to convert between address domains.
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_load_base">modes</a></b> -  Optional load modes, represented by individual constants. Supported values:

<ul><li>
 SVT_MEM_LOAD_WRITE_PROTECT - Marks the addresses initialized by the file as write protected

</li></ul>

</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>load_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_new"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>new</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
<a class="ClassLink" href="class_svt_mem_configuration.html">svt_mem_configuration</a> cfg , <a class="ClassLink" href="class_uvm_report_object.html">uvm_report_object</a> reporter       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
CONSTRUCTOR: Create a new svt_mem_core instance

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_new">cfg</a></b> -  svt_mem_configuration used to create mem_core.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_new">reporter</a></b> -  Message reporter instance
</div></td></tr>
</table>
<a class="anchor" name="item_protect"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>protect</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Create a write protect to a memory range

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_protect">addr_lo</a></b> -  low addr address
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_protect">addr_hi</a></b> -  high addr address
</div></td></tr>
</table>
<a class="anchor" name="item_reconfigure"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>reconfigure</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
<a class="ClassLink" href="class_svt_configuration.html">svt_configuration</a> cfg       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Reconfigure the memory instance.
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_reconfigure">cfg</a></b> -  - memory configuration object
</div></td></tr>
</table>
<a class="anchor" name="item_reset"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>reset</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Flush the content of the memory. 
</div></td></tr>
</table>
<a class="anchor" name="item_set_checks"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>set_checks</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
int unsigned enables       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Sets the error checking enables which determine whether particular types of
 errors or warnings will be checked by the C-based memserver application. The
 check_enables mask uses the same bits as the status values.

<p>
 The following macros can be supplied as a bitwise-OR:
 <ul>
 <li>`SVT_MEM_SA_CHECK_RD_RD_NO_WR - two reads to the same location with no intervening write.</li>
 <li>`SVT_MEM_SA_CHECK_WR_LOSS - two writes with no intervening read and the second write altered the data of that location.</li>
 <li>`SVT_MEM_SA_CHECK_WR_SAME - a location was re-written with the same data it already held.</li>
 <li>`SVT_MEM_SA_CHECK_WR_WR - two writes with no intervening read.</li>
 <li>`SVT_MEM_SA_CHECK_RD_B4_WR - a location was read before it was initialized or written.</li>
 <li>`SVT_MEM_SA_CHECK_WR_PROT - a write was attempted to a write protected instance or to a write protected location.</li>
 <li>`SVT_MEM_SA_CHECK_ADR_ERR - an address is beyond the specified address width of an instance or address range error.</li>
 <li>`SVT_MEM_SA_CHECK_DATA_ERR - a data value exceeded the specified data width in bits.</li>
 <li>`SVT_MEM_SA_CHECK_ACCESS_LOCKED - a backdoor access (peek or poke) was attempted to a location within an active access-locked range.</li>
 <li>`SVT_MEM_SA_CHECK_ACCESS_ERROR - a read or write or start_access or end_access was attempted to a location within an active access-locked memory range.</li>
 <li>`SVT_MEM_SA_CHECK_PARTIAL_RD - a read was made from a location where only some bits had been initialized. Only applies to 4-state instances.</li>
 </ul>

<p>
 Note however that not all status values represent error checks that can be
 disabled. Two pre-defined check enable defines exist:
 <ul>
 <li>`SVT_MEM_SA_CHECK_STD</li>
 <ul>
 <li>includes RD_B4_WR, PARTIAL_RD, ADR_ERR, DATA_ERR</li>
 </ul>
 <li>`SVT_MEM_SA_CHECK_ALL</li>
 <ul>
 <li>includes all checks listed above</li>
 </ul>
 </ul>

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_set_checks">enables</a></b> -  Error check enable mask
</div></td></tr>
</table>
<a class="anchor" name="item_start_access"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>start_access</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
bit mode , svt_mem_addr_t addr , svt_mem_addr_t burst_size  = 1      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Locks the address range and marks the address range provided as in the process
 of being read or written. The mark will be removed upon completion of the next
 read or write operation at that address.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_start_access">mode</a></b> -  read/write
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_start_access">addr</a></b> -  starting address to be marked
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_start_access">burst_size</a></b> -  number of addresses to be marked
</div></td></tr>
</table>
<a class="anchor" name="item_unprotect"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_core::<b>unprotect</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Release write protect to a memory range

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_unprotect">addr_lo</a></b> -  low addr address
 <p><b><a class="ClassLink" href="class_svt_mem_core.html#item_unprotect">addr_hi</a></b> -  high addr address
</div></td></tr>
</table>
</div>
<hr>
<h2 class="pre20">Member Attribute Documentation</h2>
<div style="margin-left: 0px; margin->right: 0px">
<a class="anchor" name="item_file_data_object_uids"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp;static string&nbsp;&nbsp;attribute<br>&nbsp;svt_mem_core::<b>file_data_object_uids[ int ][$]</b></td>
    </tr>
    </table>
<p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
A static associative array to keep track of the object ids for the data that
 was loaded from a file but has not yet had a parent-child relationship set
 for the corresponding "load_file" Memory Action. 
</div></td></tr>
</table>
<a class="anchor" name="item_svt_mem_core_ids"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp;static <a class="ClassLink" href="class_svt_mem_core.html">svt_mem_core</a>&nbsp;&nbsp;attribute<br>&nbsp;svt_mem_core::<b>svt_mem_core_ids[ int ]</b></td>
    </tr>
    </table>
<p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
A static associative array to map integers to instances of svt_mem_core for
 passing information about data loaded from a file back to SV from the Memory
 Server. 
</div></td></tr>
</table>
</div>
<hr size="1">
<address class="copyright"> 15 August 2018, Copyright &copy; 2018 Synopsys, Inc.</address>


<script src='dashboard.js'></script>
</body></html>
