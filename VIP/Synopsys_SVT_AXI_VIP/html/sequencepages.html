<!DOCTYPE HTML >
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>AXI SVT UVM  Documentation - Sequence Page</title>
<link href="svdoc.css" rel="stylesheet" type="text/css">
<link href="svdoctabs.css" rel="stylesheet" type="text/css">
<link href="dashboard.css" rel="stylesheet" type="text/css">
<script src="advancedsearch.js"></script>
<script src="GeneralUtility.js"></script>
<script src="PCFiltering.js"></script>
</head><body>
<!-- Generated by svdoc O-2018.09 -->
<div class="tabs"><ul>
  <li><a href="index.html" TITLE = "About this product"><span>Main&nbsp;Page</span></a></li>
  <li><a href="classhierarchy.html" TITLE = "List of all classes showing the parent/child relationship"><span>Classes</span></a></li>
  <li><a href="macros.html" TITLE = "Alphabetical listing of macros"><span>Macros</span></a></li>
  <li><a href="level1_covergroups.html" TITLE = "Coverage"><span>Coverage</span></a></li>
  <li><a href="protocolChecks.html" TITLE = "List of Protocol Checks defined in VIP"><span>Protocol&nbsp;Checks</span></a></li>
  <li id="current"><a href="sequencepages.html" TITLE = "List of Sequences"><span>Sequences</span></a></li>
  <li><a href="interfaces.html" TITLE = "List of Interfaces"><span>Interfaces</span></a></li>
  <li><a href="globals.html" TITLE = "Global members"><span>Globals</span></a></li>
  <li><a href="indexall.html" TITLE = "Complete Index of all Source Code Elements"><span>Index</span></a></li>
  <li><a href="help.html" TITLE = "Help"><span>?</span></a></li>
  <li><form action="javascript:SearchFunction(form.searchtext.value, '', form.searchmode.value)"><table border="0"><tr>
    <td><input NAME="searchbtn" TYPE=button VALUE=" Search " onChange="SearchFunction(form.searchtext.value, '', form.searchmode.value)"></td>
    <td><input NAME="searchtext" TYPE=text VALUE="" onChange="SearchFunction(form.searchtext.value, '', form.searchmode.value)"></td>
    <td><select NAME="searchmode" TYPE=text >
          <option value=simple>simple</option>
          <option value=regexpr>reg expr</option>
    </select></td>
  </tr></table></form></li>
</ul></div>
<h1>AXI SVT UVM  Documentation - Sequence Page</h1>
<p> svt_sequence class inheritance diagram.</p>
 <input id="toggle_svt_sequence" value="+" onclick=toggleDiv("hdiv_svt_sequence","toggle_svt_sequence") title="svt_sequence class inheritence diagram" type="button"//><div id="hdiv_svt_sequence" style="display:none;"><p><center><img src="svt_sequence.png" USEMAP="#svt_sequence" border="0" alt=""> </center>
</div><p> Sequences defined in AXI SVT UVM  Documentation: </br>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%"  border="1"> 
<tr>
<th class="MemberListLeft" valign="bottom" > Sequence Group </th>
<th class="MemberListLeft" valign="bottom" > Sequences </th>
<th class="MemberListLeft" valign="bottom" > Sequences Description </th>
<th class="MemberListLeft" valign="bottom" > Controls</th>
<th class="MemberListLeft" valign="bottom" > Sequencer </th>
</tr>
<tr>
<td rowspan = 152 class="MemberListLeft" valign="center" > <b>default</b> </td>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_base_sequence.html"> svt_axi_master_base_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence raises/drops objections in the pre/post_body so that root
 sequences raise objections but subsequences do not. All other master sequences
 in the collection extend from this base sequence. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_base_sequence.html#item__read_xact_type">_read_xact_type<div>Following are the possible transaction types:
 WRITE : Represent a WRITE transaction. 
 READ : Represents a READ transaction.
 COHERENT : Represents a COHERENT transaction.

</div></a>
<br><a class="inhlist" href="class_svt_axi_master_base_sequence.html#item__write_xact_type">_write_xact_type<div>Description-Unavailable</div></a>
<br> </td>
<td rowspan = 33 class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_sequencer.html"> svt_axi_master_sequencer </a></td> 
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_base_sequence.html"> svt_axi_ace_master_base_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Base class from which all the ACE non-virtual sequences are extended. This
 class is the base class for sequences that run on multiple master
 sequencers. In addition to being extended to create new sequences, this
 sequence is also called within some virtual sequences like
 svt_axi_cacheline_initialization and svt_axi_cacheline_invalidation. This
 sequence cannot be used as is, but must be called from within a virtual
 sequence that is extended from svt_axi_ace_master_base_virtual_sequence. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_base_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_base_sequence.html#item_use_directed_addr">use_directed_addr<div>Indicates that the addresses provided in directed_addr_mailbox should be used
 for the transactions generated by this sequence</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_barrier_flag_read_xact_sequence.html"> svt_axi_ace_barrier_flag_read_xact_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends a single READONCE transaction that writes into a location within the
 given domain type and address. The transaction addresses a single byte and is meant as one 
 which reads a flag set by another transaction. Typically this is used to read a flag 
 set through a post barrier transaction sent from another port. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_barrier_flag_read_xact_sequence.html#item_flag_domain_type">flag_domain_type<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_barrier_flag_read_xact_sequence.html#item_flag_addr">flag_addr<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_barrier_flag_write_xact_sequence.html"> svt_axi_ace_barrier_flag_write_xact_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends a single WRITEUNIQUE transaction that writes into a location within the
 given domain type. The transaction addresses a single byte and is meant as a flag
 which can later be read by other transactions. Typically this is used as a post barrier
 transaction to signal availability/observability of a number of pre barrier transactions </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_barrier_flag_write_xact_sequence.html#item_flag_domain_type">flag_domain_type<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_barrier_pair_sequence.html"> svt_axi_ace_barrier_pair_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends a barrier pair </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_barrier_pair_sequence.html#item_myDomain">myDomain<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_barrier_readnosnoop_sequence.html"> svt_axi_ace_barrier_readnosnoop_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends a single READNOSNOOP transaction that reads from the same location 
 as write_xact. Associates the READ to a barrier based on associate_barrier </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_exclusive_access_sequence.html"> svt_axi_ace_exclusive_access_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence is used to create Exclusive Access Transactions at Master port level<br>
<br>
 Transaction Sequences Used: Exclusive Load followed by Exclusive store 

<ul><li>
 Initialize cache lines if initialize_cachelines bit is set 

</li><li>
 Issue READCLEAN or READSHARED to load location and wait for the transaction to end

</li><li>
 Check the cache line state

<ul><li>
 if in Shared state issue CLEANUNIQUE 

</li><li>
 if in Invalid state then restart Exclusive Access

</li><li>
 else do nothing as Master can store directly to the cacheline no need to inform Interconnect

</li></ul>


</li><li>
 Stored data is updated to memory through WRITEBACK transaction

</li></ul>

 <br>
 Please note, for generation of exclusive access transactions, svt_axi_port_configuration :: exclusive_access_enable 
 should be set for the targeted master. <br>
 <br>  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_exclusive_access_sequence.html#item_exc_burst_length">exc_burst_length<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_exclusive_access_sequence.html#item_exc_burst_size">exc_burst_size<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_exclusive_access_sequence.html#item_exc_burst_type">exc_burst_type<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_exclusive_access_sequence.html#item_exc_domain">exc_domain<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_exclusive_access_sequence.html#item_exclusive_axi4_slave">exclusive_axi4_slave<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_exclusive_access_sequence.html#item_num_of_exclusive_seq_restart">num_of_exclusive_seq_restart<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_exclusive_access_sequence.html#item_random_nonexclusive_store_overlap_with_exclusive_store_wt">random_nonexclusive_store_overlap_with_exclusive_store_wt<div>represents percentage value of sending random non-exclusive store overlapping with exclusive store.
 Must set values between 0 to 100 </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_generic_sequence.html"> svt_axi_ace_master_generic_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Generic sequence that can be used to generate transactions of all types on
 a master sequencer. All controls are provided in the base class
 svt_axi_ace_master_base_sequence. Please refer documentation of
 svt_axi_ace_master_base_sequence for controls provided. This class only
 adds constraints to make sure that it can be directly used in a testcase
 outside of a virtual sequence. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_basic_writeback_full_cacheline.html"> svt_axi_basic_writeback_full_cacheline </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a writeback transaction for a full cacheline. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_basic_writeclean_full_cacheline.html"> svt_axi_basic_writeclean_full_cacheline </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a writeclean transaction for a full cacheline. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_dvm_base_sequence.html"> svt_axi_ace_master_dvm_base_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates dvm transactions with all possible dvm message types
 from ACE or ACE-Lite+DVM master ports. This sequence is used as a base
 sequence for higher level sequences, with proper constraints for sequence
 members dvm_message_type and seq_xact_type  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_dvm_base_sequence.html#item_seq_xact_type">seq_xact_type<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_dvm_base_sequence.html#item_dvm_message_type">dvm_message_type<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_dvm_complete_sequence.html"> svt_axi_ace_master_dvm_complete_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence sends DVM Complete transactions from ACE or ACE-Lite+DVM Master
 ports. It takes care of the ACE protocol requirement that DVM Sync handshake
 on the snoop address channel be observed before issuing DVM Complete transaction.  </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_aligned_addr_sequence.html"> svt_axi_master_aligned_addr_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates the transactions whose address is always aligned with
 respect to burst size. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_aligned_addr_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in this sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_blocking_alternate_write_read_sequence.html"> svt_axi_master_blocking_alternate_write_read_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates alternate write and read transaction. All other
 transaction fields are randomized. The sequence waits for each transaction
 to complete, before sending the next transaction. This sequence is valid
 only when <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> =
 AXI_READ_WRITE. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_blocking_alternate_write_read_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in this sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_blocking_write_read_sequence.html"> svt_axi_master_blocking_write_read_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a sequence of write transactions, followed by a
 sequence of read transactions. All other transaction fields are randomized.
 The sequence waits for each transaction to complete, before sending the next
 transaction. This sequence is valid only when
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> = AXI_READ_WRITE. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_blocking_write_read_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in a sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_exclusive_memory_test_sequence.html"> svt_axi_master_exclusive_memory_test_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs the following 
 1) Exclusive read transaction
 2) Normal write transaction with same ID, ADDR and other control fields as
 previous Exclusive read
 3) Exclusive write transaction with same ID, ADDR and other control fields as
 previous Exclusive read </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_exclusive_normal_wrap_test_sequence.html"> svt_axi_master_exclusive_normal_wrap_test_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs the following
 1) Exclusive read transaction with WRAP burst type 
 2) Normal write transaction with different ID and address overlapping to the
 address of previous exclusive read
 3) Exclusive write transaction matching to the previous Exclusive read </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_exclusive_random_test_sequence.html"> svt_axi_master_exclusive_random_test_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs the following 
 1) Normal read and write transactions 
 2) Exclusive read and write transactions 
 3) Normal read and write transactions 
 4) Exclusive read and write transactions  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_exclusive_random_test_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in this sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_exclusive_read_after_read_test_sequence.html"> svt_axi_master_exclusive_read_after_read_test_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs the following
 1) Series of Exclusive read transactions 
 2) Series of Exclusive write transactions  </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_exclusive_test_sequence.html"> svt_axi_master_exclusive_test_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs Exclusive read transaction followed by Exclusive
 write transaction with same control fields as previous Exclusive read.
 Exclusive write commences only after response for Exclusive read is
 received by the master. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_exclusive_test_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in this sequence. </div></a>
<br><a class="inhlist" href="class_svt_axi_master_exclusive_test_sequence.html#item_slv_num">slv_num<div>Indicates the slave number to be targetted </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_locked_read_followed_by_excl_sequence.html"> svt_axi_master_locked_read_followed_by_excl_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs locked followed by exclusive accesses 
 Each loop does the following:
 Send a locked access read transaction followed by a excluisve read transaction
 Send the exclusive read transactions with same id as of locked read transaction
 Each transcation waits for the previous transaction to be ended </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_locked_read_followed_by_excl_sequence.html#item_slv_num">slv_num<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_locked_test_sequence.html"> svt_axi_master_locked_test_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs locked accesses 
 Each loop does the following:
 Send a normal transaction
 Send a locked access transaction that starts the locked sequeunce
 Send more locked access transactions
 Send a normal transactions that ends the locked sequence
 An intermediate loop sends only NORMAL transactions (represented by k == 5) </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_locked_test_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in this sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_normal_exclusive_random_sequence.html"> svt_axi_master_normal_exclusive_random_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs the following
 send back to back four transactions
 The atomic type is randomized to exclusive or normal for each transaction </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_normal_exclusive_random_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in this sequence. </div></a>
<br><a class="inhlist" href="class_svt_axi_master_normal_exclusive_random_sequence.html#item_slv_num">slv_num<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_outstanding_dvm_tlb_invalidate_xacts_sequence.html"> svt_axi_master_outstanding_dvm_tlb_invalidate_xacts_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a sequence of DVM TLB Invalidate transactions.
 All other transaction fields are randomized. The sequence does not wait for transactions
 to complete before sending next transaction. This is required in order to generate 
 outstanding DVM TLBI transactions. This sequence is targetted to hit the following
 covergroups.
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_ace_num_outstanding_dvm_tlb_invalidate_xacts_with_same_arid">trans_ace_num_outstanding_dvm_tlb_invalidate_xacts_with_same_arid</a>
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_ace_num_outstanding_dvm_tlb_invalidate_xacts_with_diff_arid">trans_ace_num_outstanding_dvm_tlb_invalidate_xacts_with_diff_arid</a>
 This sequence requires <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> = <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_READ_WRITE">AXI_READ_WRITE</a>
 and <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> is either ACE or ACE-Lite. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_outstanding_dvm_tlb_invalidate_xacts_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in a sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_outstanding_snoop_xacts_sequence.html"> svt_axi_master_outstanding_snoop_xacts_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a sequence of coherent READONCE transactions.
 All other transaction fields are randomized. The sequence does not wait for transactions
 to complete before sending next transaction. This is required in order to generate 
 outstanding snoop transactions. This sequence is targetted to hit the following
 covergroups.
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_ace_num_outstanding_snoop_xacts">trans_ace_num_outstanding_snoop_xacts</a>
 This sequence requires <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> is set to 
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_READ_WRITE">AXI_READ_WRITE</a> or <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_READ_ONLY">AXI_READ_ONLY</a>
 and <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> is set to AXI_ACE or ACE_LITE. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_outstanding_snoop_xacts_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in a sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_outstanding_xact_id_sequence.html"> svt_axi_master_outstanding_xact_id_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a sequence of coherent writenosnoop transactions,
 followed by coherent readnosnoop transactions. All other transaction fields
 are randomized. The sequence does not wait for transactions to complete
 before sending next transaction. This is required in order to generate 
 outstanding transactions. This sequence is targetted to hit the following
 covergroups.
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_same_arid">trans_axi_num_outstanding_xacts_with_same_arid</a>
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_diff_arid">trans_axi_num_outstanding_xacts_with_diff_arid</a>
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_same_awid">trans_axi_num_outstanding_xacts_with_same_awid</a>
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_diff_awid">trans_axi_num_outstanding_xacts_with_diff_awid</a>
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_multiple_same_arid">trans_axi_num_outstanding_xacts_with_multiple_same_arid</a>
 <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html">svt_axi_port_monitor_def_cov_callback</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_monitor_def_cov_callback.html#item_trans_axi_num_outstanding_xacts_with_multiple_same_awid">trans_axi_num_outstanding_xacts_with_multiple_same_awid</a>
 This sequence requires <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> = <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_READ_WRITE">AXI_READ_WRITE</a>
 and <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> is either ACE or ACE-Lite. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_outstanding_xact_id_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in a sequence. </div></a>
<br><a class="inhlist" href="class_svt_axi_master_outstanding_xact_id_sequence.html#item_multi_same_id_select">multi_same_id_select<div>If set, then the sequence will initiate WRITENOSNOOP and READNOSNOOP
 transactions with multiple same ids </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_random_sequence.html"> svt_axi_master_random_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates random master transactions. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_random_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in a sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_write_data_before_addr_sequence.html"> svt_axi_master_write_data_before_addr_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates write data before address. This is valid when
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_category">axi_interface_category</a> = AXI_READ_WRITE or
 AXI_WRITE_ONLY. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_write_data_before_addr_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in this sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_write_data_fixed_interleave_block_sequence.html"> svt_axi_master_write_data_fixed_interleave_block_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates write interleaved data with interleave size of each
 block equal to one by default. User can modify the interleave block size by
 setting <a class="ClassLink" href="class_svt_axi_master_write_data_fixed_interleave_block_sequence.html#item_interleave_block_size">interleave_block_size</a>. This is valid when
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> = AXI3. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_master_write_data_fixed_interleave_block_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in this sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_random_sequence.html"> svt_axi_random_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a random sequences of write transaction or 
 of read transaction. All other transaction fields are randomized. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_random_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in a sequence. </div></a>
<br><a class="inhlist" href="class_svt_axi_random_sequence.html#item_slv_num">slv_num<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_random_sequence.html#item_xact_length">xact_length<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html"> svt_axi_read_same_slave_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a Read transactions with overlapping addr/non overlapping
 addr/random addr to the same slave. Remaining fields are randomized.
 It generates the write followed by read transaction and waiting for write transaction
 to complete,then execute the read transaction with same write transaction accessing address. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_xact_length">xact_length<div>Number of transaction used to constrain in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_id">id<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_min_id">min_id<div>Read Id width </div></a>
<br><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_rd_id">rd_id<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_slv_num">slv_num<div>Slave number used to constrain </div></a>
<br><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_address">address<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_memory_type">memory_type<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_read_same_slave_sequence.html#item_do_write_before_read">do_write_before_read<div>Write before read used to constrain </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html"> svt_axi_write_same_slave_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates a Write transactions with overlapping addr/non overlapping
 addr/random addr to the same slave. Remaining fields
 are randomized. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_num_of_wr_xact">num_of_wr_xact<div>Number of Write transaction in used to constrain it in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_id">id<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_min_id">min_id<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_wr_id">wr_id<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_slv_num">slv_num<div>Slave number used to constrain it </div></a>
<br><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_address">address<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_memory_type">memory_type<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_write_same_slave_sequence.html#item_interleave">interleave<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi3_master_random_read_write_locked_sequence.html"> svt_axi3_master_random_read_write_locked_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence performs locked accesses 
 Each loop does the following:
 Send a random locked access transaction.
 Send the exclusive transaction with same xact_type and address as of locked transaction to unlock the locked sequence
 Each transcation waits for the previous transaction to be ended </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi3_master_random_read_write_locked_sequence.html#item_slv_num">slv_num<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_snoop_base_sequence.html"> svt_axi_master_snoop_base_sequence </a> </td>
<td class="MemberListLeft" valign="center" > AXI ACE base master snoop response reactive sequence </td>
<td  valign="center" >  --  </td>
<td rowspan = 2 class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_master_snoop_sequencer.html"> svt_axi_master_snoop_sequencer </a></td> 
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_snoop_response_sequence.html"> svt_axi_ace_master_snoop_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Reactive response sequence that services snoop requests
 using the cache located in the parent svt_axi_master_snoop_sequencer.
 Automatically configured as the run_phase default sequence for every instance of
 the svt_axi_master_snoop_sequencer.

<p>
 If data is available in the cache, that data is populated into the
 snoop transaction. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_base_sequence.html"> svt_axi_slave_base_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence raises/drops objections in the pre/post_body so that root
 sequences raise objections but subsequences do not. All other slave sequences
 in the collection extend from this base sequence.

<p>
 Execution phase: run_phase
 Sequencer: Slave agent sequencer </td>
<td  valign="center" >  --  </td>
<td rowspan = 18 class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_sequencer.html"> svt_axi_slave_sequencer </a></td> 
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_exclusive_sequence.html"> svt_axi_slave_exclusive_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence is used for the exclusive transactions. It gets the slave
 response sequence item from slave sequencer. F?or exclusive access
 transactions, response is not randomized as the response is pre-computed by
 the slave, based on exclusive access monitors. If the pre-computed response
 is modified, the response may not comply with exclusive access rules. For
 read transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. For normal transactions,
 randomized response provided to the slave driver. This sequence runs
 forever, and so is not registered with the slave sequence library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_memory_sequence.html"> svt_axi_slave_memory_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_diff_write_resp_for_diff_masters_sequence.html"> svt_axi_slave_diff_write_resp_for_diff_masters_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence responds out-of-order and issues OKAY response for multiple write
 transactions from master M0 and SLVERR response for multiple write transactions from
 master M1.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_get_xact_request_sequence.html"> svt_axi_slave_get_xact_request_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence trigger event(xact_request_received_event) when transaction 
 request is received to communicate the other block.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_memory_suspend_response_sequence.html"> svt_axi_slave_memory_suspend_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence suspends the response of write transaction ,resumes it after 
 after read transactions reaches the slave. 
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_okay_slverr_resp_sequence.html"> svt_axi_slave_okay_slverr_resp_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence asserts slave response.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave responds as OKAY response for first write transaction and SLVERR
 response for second write transaction. The sequence uses the built-in slave memory.
 For write transactions, it writes the data into slave memory. The programmed response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_ordering_memory_suspend_response_sequence.html"> svt_axi_slave_ordering_memory_suspend_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence suspends the response of write transaction ,resumes it after 
 after read transactions reaches the slave. 
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_ordering_programmed_response_sequence.html"> svt_axi_slave_ordering_programmed_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence gets the slave response sequence item from slave sequencer.
 User can modify these responses. The sequence uses the built-in slave memory. 
 For write transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_programmed_response_sequence.html"> svt_axi_slave_programmed_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence gets the slave response sequence item from slave sequencer.
 User can modify these responses. The sequence uses the built-in slave memory. 
 For write transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_suspend_read_response_on_address_sequence.html"> svt_axi_slave_suspend_read_response_on_address_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence suspends the response of write transaction and resumes it, 
 after sending the response of immediate read transaction.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_suspend_read_response_sequence.html"> svt_axi_slave_suspend_read_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence suspends the response of write transaction and resumes it, 
 after sending the response of immediate read transaction.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_suspend_write_response_on_address_sequence.html"> svt_axi_slave_suspend_write_response_on_address_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence suspends the response of write transaction and resumes it, 
 after sending the response of immediate read transaction.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_suspend_write_response_sequence.html"> svt_axi_slave_suspend_write_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence suspends the response of write transaction and resumes it, 
 after sending the response of immediate read transaction.
 This sequence gets the slave response sequence item from slave sequencer.
 The slave response is then randomized based on certain weights. User can
 modify these weights. The sequence uses the built-in slave memory. For read
 transactions, it reads the data from the slave memory. For write
 transactions, it writes the data into slave memory. The randomized response
 is then provided to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_traffic_profile_sequence.html"> svt_axi_slave_traffic_profile_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence is used by the VIP to map traffic profile properties to AXI
 transaction properties. Traffic profile attributes are modelled as properties of
 this sequence. These are mapped to transaction level properties in the body of
 the sequence. Users could potentially use this sequence even if 
 traffic profiles are not used if the attributes of this sequence map to
 the requirements of modelling the response parameters of slaves in their system </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_read_data_fixed_interleave_block_sequence.html"> svt_axi_slave_read_data_fixed_interleave_block_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates read interleaved data with interleave size of each
 block equal to one by default. User can modify the interleave block size by
 setting <a class="ClassLink" href="class_svt_axi_slave_read_data_fixed_interleave_block_sequence.html#item_interleave_block_size">interleave_block_size</a>.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_response_sequence.html"> svt_axi_slave_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates random responses to response requests. This sequence
 gets the slave response sequence item from slave sequencer, randomizes the
 response, and provides the randomized response to the slave driver.

<p>
 This sequence runs forever, and so is not registered with the slave sequence
 library. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_tlm_response_sequence.html"> svt_axi_slave_tlm_response_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence is used as Reactive seuqnce which translates slave transactions into
 corresponding AMBA-PV extended TLM Generic Payload Transactions and forwards it via
 the resp_socket socket for fulfillment by an AMBA-PV Slave.
 The response returned by the socket is then sent back to the driver.

<p>
 Automatically configured as the run_phase default sequence for every instance of
 the svt_axi_slave_sequencer if the use_pv_socket property in the port configuration is TRUE </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_random_snoop_sequence.html"> svt_axi_slave_random_snoop_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Description-Unavailable </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_slave_random_snoop_sequence.html#item_sequence_length">sequence_length<div>Parameter that controls the number of transactions that will be generated </div></a>
<br> </td>
<td rowspan = 1 class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_slave_snoop_sequencer.html"> svt_axi_slave_snoop_sequencer </a></td> 
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_system_base_sequence.html"> svt_axi_system_base_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence creates a reporter reference </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_system_base_sequence.html#item__read_xact_type">_read_xact_type<div>Following are the possible transaction types:
 WRITE : Represent a WRITE transaction. 
 READ : Represents a READ transaction.
 COHERENT : Represents a COHERENT transaction.

</div></a>
<br><a class="inhlist" href="class_svt_axi_system_base_sequence.html#item__write_xact_type">_write_xact_type<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_system_base_sequence.html#item_initiating_master_index">initiating_master_index<div>Initiating Master index *</div></a>
<br><a class="inhlist" href="class_svt_axi_system_base_sequence.html#item_active_participating_slave_index">active_participating_slave_index<div>Initiating Slave index *</div></a>
<br><a class="inhlist" href="class_svt_axi_system_base_sequence.html#item_participating_slave_index">participating_slave_index<div>Initiating Slave index *</div></a>
<br> </td>
<td rowspan = 94 class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_system_sequencer.html"> svt_axi_system_sequencer </a></td> 
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_base_virtual_sequence.html"> svt_axi_ace_master_base_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This is a virtual sequence and is the base class for other virtual sequences
 in the sequence library. The sequence spawns off a thread that waits on an
 event before it starts a sequence to initialize cachelines of peer masters.  </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_barrier_base_virtual_sequence.html"> svt_axi_ace_master_barrier_base_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence is a base class for all barier based sequences. This sequence cannot be run
 as such, but contains methods which are used by other barrier sequences

<p>
 NOTE: Continuous polling may need adding interval between two consecutive transactions. See
 poll_barrier_flag_and_check_post_barrier_contents task for details. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_barrier_base_virtual_sequence.html#item_domain_type">domain_type<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_load_barrier_sequence.html"> svt_axi_ace_master_load_barrier_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence does the following:
 Send a number of transactions to load . The number of transactions sent
 is based on num_pre_barrier_loads. 
 Send a barrier pair
 Send a post barrier transaction that is associated to the barrier pair. This transaction
 will be send out only after the response to the barrier pair is received
 When the post barrier transaction ends, check that all pre barrier transactions have also
 ended.  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_load_barrier_sequence.html#item_num_pre_barrier_loads">num_pre_barrier_loads<div>Number of pre-barrier stores to be issued before issuing a barrier and post-barrier transaction </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_load_barrier_sequence.html#item_num_ports">num_ports<div>Number of ports from which the sequence needs to be executed </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_nonshareable_store_barrier_load_sequence.html"> svt_axi_ace_master_nonshareable_store_barrier_load_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence does the following:
 Sends a number of pre barrier write transactions based on num_pre_barrier_stores
 Sends a barrier pair
 Sends post barrier read transaction to the same address.
 Since the reads are post barrier transactions, all the previous writes should be
 observable to the reads 
 All write transactions sends are WRITENOSNOOP transaction and read transactions
 are READNOSNOOP transactions </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_nonshareable_store_barrier_load_sequence.html#item_num_pre_barrier_stores">num_pre_barrier_stores<div>Number of pre-barrier stores to be issued before issuing a barrier and post-barrier transaction </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_nonshareable_store_barrier_load_sequence.html#item_num_ports">num_ports<div>Number of ports from which the sequence must be executed </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_shareable_store_barrier_load_sequence.html"> svt_axi_ace_master_shareable_store_barrier_load_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence does the following:
 Sends a number of pre barrier store transactions based on num_pre_barrier_stores
 Sends a barrier pair
 Sends a post barrier flag transaction. Any master that can observe this flag should be
 able to observe the transactions before the barrier
 From another port in the same domain, the location written through the flag transaction is 
 continously read (load). When the value set through the flag transaction is read back, the loop 
 terminates. The flag transaction is a post-barrier transaction, so if its value is observable, 
 It then reads back all the locations written through the pre barrier store transactions and 
 checks that all the data that was written is read back correctly. Thus, this sequence is
 self-checking. Note that this step is not done if pre_barrier_xact_type is PRE_BARRIER_CACHE_MAINTENANCE 
 since the data is not available in cache maintenance transactions. Instead, the sequence checks 
 that when a post-barrier transaction completes all pre-barrier cache maintenance transactions
 should have completed.
 The ports on which the pre barrier stores and the loads are sent are randomly chosen
 based on configuration. The type of store transaction is based on the setting in 
 pre_barrier_xact_type. Loads can be READSHARED,READONCE,READCLEAN or
 READNOTSHAREDDIRTY. 
 Some interesting scenarios that can be exercised using this sequence are.
 Each of these scenarios is repeated for sequence_length:
 1. num_pre_barrier_stores=1,num_observers=1 : A single pre-barrier store
 followed by a post barrier flag with one observer reading the post barrier
 flag and later reading the location addressed by pre_barrier store. 
 2. num_pre_barrier_stores=1,num_observers>1 : A single pre-barrier store
 followed by a post barrier flag with many observers reading the post barrier
 flag and later reading the location addressed by pre_barrier store. 
 3. num_pre_barrier_stores>1,num_observers=1 : Many pre-barrier stores
 followed by a post barrier flag with one observer reading the post barrier
 flag and later reading the locations addressed by pre_barrier store. 
 4. num_pre_barrier_stores>1,num_observers>1 : Many pre-barrier stores
 followed by a post barrier flag with many observers reading the post barrier
 flag and later reading the locations addressed by pre_barrier store. 

<p>
 NOTE: Continuous polling may need adding interval between two consecutive transactions. See
 poll_barrier_flag_and_check_post_barrier_contents task for details.
 This task is part of class svt_axi_ace_master_barrier_base_virtual_sequence
 from which current class is derived. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_shareable_store_barrier_load_sequence.html#item_first_port_id">first_port_id<div>Represents the master port from which the sequence will be initiated. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_shareable_store_barrier_load_sequence.html#item_second_port_id">second_port_id<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_shareable_store_barrier_load_sequence.html#item_pre_barrier_xact_type">pre_barrier_xact_type<div>The kind of pre-barrier transactions </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_shareable_store_barrier_load_sequence.html#item_num_pre_barrier_stores">num_pre_barrier_stores<div>Number of pre-barrier stores to be issued before issuing a barrier and post-barrier transaction </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_shareable_store_barrier_load_sequence.html#item_num_observers">num_observers<div>Number of ports that are observing the pre barrier stores. The location written 
 through the flag transaction is read from this many ports that fall in the
 same domain</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_dvm_virtual_sequence.html"> svt_axi_ace_master_dvm_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence sends DVM operations followed by a DVM sync from one port or multiple
 ports of a given domain. Prior to sending DVM operations and DVM sync a few normal transactions
 as specified in num_pre_dvm_xacts is sent. The above sequence is repeated for sequence_length.
 The sequence also triggers another sequence that sends DVM Complete transactions from ports that receive DVM Syncs. 
 The sequence terminates only when DVM completes for each of the DVM syncs sent out
 from a port are received from the interconnect
 This sequence is not added to the library (except for documentation) because it kills any
 snoop response sequences supplied by the testbench to run a dvm specific snoop response. Adding
 it to the library and running it may cause undesirable results and therefore this sequence must 
 be run in a separate test </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_dvm_virtual_sequence.html#item_multi_port_type">multi_port_type<div>Indicates if DVM transactions need to be sent from only one port in a 
 given domain or from all ports in a domain
 Currently supports only ONE_MASTER</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_dvm_virtual_sequence.html#item_num_pre_dvm_xacts">num_pre_dvm_xacts<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_dvm_virtual_sequence.html#item_domain_type">domain_type<div>The shareability domain of the DVM transactions to be sent</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_multipart_dvm_virtual_sequence.html"> svt_axi_ace_master_multipart_dvm_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends Multi-Part DVM Transaction from randomly selected ports. While sending multipart dvm
 transactions it also sends dvm transactions from same port along with coherent shareable and
 non-shareable transactions from same and other ports. Multipart and singlepart DVM transactions
 are sent simulataneously from one or more randomly selected ports in parallel.
 Scenarios Covered::

<ul><li>
 independent write channel transaction progress along with dvm transactions

</li><li>
 independency of ID usage between write channel transactions and DVM transactions

</li><li>
 independent read channel transaction progress along with dvm transactions

</li><li>
 ID usage restrictions between read channel non-dvm transactions and DVM transactions

</li><li>
 multi-part DVM transactions

</li><li>
 multi-part DVM transactions with second part having DVM Sync and other opcodes

</li><li>
 multi-part DVM Sync transactions with second part having DVM Sync and other opcodes

</li><li>
 time overlapped multi-part dvm and non-multi-part dvm transactions

</li><li>
 time overlapped coherent write, coherent read and multi-part dvm and non-multi-part dvm transactions

</li></ul>
 </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_single_port_base_virtual_sequence.html"> svt_axi_ace_master_single_port_base_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Base class from which all ACE basic level sequences will be extended.  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_single_port_base_virtual_sequence.html#item_port_id">port_id<div>Represents the master port from which the sequence will be initiated. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_single_port_base_virtual_sequence.html#item_sequence_length">sequence_length<div>Represents the length of the sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html"> svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates concurrent random non-dvm transactions from first_port_id and
 dvm transactions from dvm_port_id. These ports can be a random port or a specifc port 
 configured by user through uvm_config_db. Based on the interface type of first_port_id, 
 a transction type as set in first_port_xact_type is sent from first_port_id. 
 Before sending the transactions, cachelines of peer masters are initialized to random valid states. 
 Initialisation is done through front door access, by sending specific transactions from the 
 initiating master (corresponding to first_port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_first_port_id">first_port_id<div>Represents the port for sending non-DVM transactions. 
 Valid only if send_non_dvm_xact_select is set.
 first_port_id may be the same as dvm_port_id1 or dvm_port_id2. However,
 if dvm_port1_multipart_select is set, first_port_id cannot be dvm_port_id1.
 The same applies to dvm_port2_multipart_select and dvm_port_id2. This is
 because non-DVM transactions cannot be sent between two multipart DVM
 transactions
 This property can be controlled via uvm_config_db. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_dvm_port_id1">dvm_port_id1<div>Represents the first dvm master port. This property can be controlled via uvm_config_db. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_dvm_port_id2">dvm_port_id2<div>Represents the second dvm master port. This property can be controlled via uvm_config_db. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_dvm_port1_multipart_select">dvm_port1_multipart_select<div>Represents the multipart dvm transaction selection for dvm_port_id1. 
 Note that if the dvm_message_type selected is TLB_INVALIDATE,
 PHYSICAL_INSTRUCTION_CACHE_INVALIDATE or VIRTUAL_INSTRUCTION_CACHE_INVALIDATE,
 the randomized values of tlb_operation, physical_instruction_invalidate_operation and
 virtual_instruction_invalidate_operation determine whether a DVM transaction will be
 multipart or not. 
 This property can be controlled via uvm_config_db. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_dvm_port2_multipart_select">dvm_port2_multipart_select<div>Represents the multipart dvm transaction selection for dvm_port_id2. 
 Note that if the dvm_message_type selected is TLB_INVALIDATE,
 PHYSICAL_INSTRUCTION_CACHE_INVALIDATE or VIRTUAL_INSTRUCTION_CACHE_INVALIDATE,
 the randomized values of tlb_operation, physical_instruction_invalidate_operation and
 virtual_instruction_invalidate_operation determine whether a DVM transaction will be
 multipart or not. 
 This property can be controlled via uvm_config_db. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_send_non_dvm_xact_from_first_port_select">send_non_dvm_xact_from_first_port_select<div>Sends non dvm transactions on first_port_id if set to 1, 
 Sends only dvm messages without non dvm transactions if set to 0.
 This property can be controlled via uvm_config_db.</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_send_non_dvm_xact_from_dvm_port_select">send_non_dvm_xact_from_dvm_port_select<div>Sends non-dvm transactions along with DVM transactions from dvm_port_id1
 and dvm_port_id2. Only transactions which can be sent out without
 initializing the cacheline are used. These transactions are WRITENOSNOOP,
 READNOSNOOP, MAKEUNIQUE, READUNIQUE, READSHARED, READCLEAN,
 READNOTSHAREDDIRTY, CLEANINVALID, CLEANSHARED, MAKEINVALID, WRITEUNIQUE,
 WRITELINEUNIQUE.</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_num_non_dvm_xacts_from_dvm_port">num_non_dvm_xacts_from_dvm_port<div>Applicable when send_non_dvm_xact_from_dvm_port_select is set.
 Indicates the number of non dvm transactions to be sent after
 num_dvm_xacts_before_non_dvm_xact number of DVM transactions are sent
 Once the non-dvm transactions are sent, DVM transactions are represented
 by num_dvm_xacts_before_non_dvm_xact are sent again. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_num_dvm_xacts_before_non_dvm_xact">num_dvm_xacts_before_non_dvm_xact<div>Applicable when send_non_dvm_xact_from_dvm_port_select is set.
 Indicates the number of DVM transactions to be sent before non-DVM
 transactions are sent. Once the non-dvm transactions are sent, DVM
 transactions as represented by the this variable are sent before
 sending non-DVM transactions. Hence the sequence of 
 DVM based on num_dvm_xacts_before_non_dvm_xact, non-DVM based on
 num_non_dvm_xacts_from_dvm_port is repeated.</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_tlb_operation">tlb_operation<div>The tlb_operation represents the tlb sub operation to be sent from test </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_physical_instruction_invalidate_operation">physical_instruction_invalidate_operation<div>The physical_instruction_invalidate_operation represents the physical instruction invalidate
 sub operation to be sent from test </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_virtual_instruction_invalidate_operation">virtual_instruction_invalidate_operation<div>The virtual_instruction_invalidate_operation represents the virtual instruction invalidate
 sub operation to be sent from test</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_dvm_message_type">dvm_message_type<div>The dvm_message_type represents the dvm message to be sent from test.
 This property can be controlled via uvm_config_db. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_first_port_xact_type">first_port_xact_type<div>Random coherent non-dvm transaction type for first_port_id 
 This property can be controlled via uvm_config_db.</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_domain_type">domain_type<div>The shareability domain of the DVM transactions to be sent</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_dvm_os_select">dvm_os_select<div>The dvm os type of the DVM transactions to be sent</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_dvm_security_select">dvm_security_select<div>The dvm security type of the DVM transactions to be sent</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_concurent_non_dvm_xacts_with_dvm_xacts_sequence.html#item_two_port_interface_type">two_port_interface_type<div>Represents the interface types for the first port and dvm port, 
 selected according to the number of AXI_ACE and ACE_LITE ports collected 
 through find_dvm_ports function</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_cachemaintenance_sequential_sequence.html"> svt_axi_ace_master_cachemaintenance_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of cache maintenance transactions to consecutive address locations
 #- Cache maintenance transactions can be MAKEINVALID, CLEANSHARED or CLEANINVALID
 transactions.
 #- The weights for these transactions can be passed through uvm_config_db.
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port can be ACE or ACE-Lite port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_cleaninvalid_sequence.html"> svt_axi_ace_master_cleaninvalid_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates CleanInvalid transaction from the ACE/ACE-Lite
 master specified with port_id , which can be a random port or a specific
 port configured by the user through uvm_config_db. CleanInvalid
 transactions can be sent only when the
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master corresponding
 to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>. Before sending CleanInvalid
 transactions, cachelines of peer masters are initialized to random, valid
 states. Initialisation is done through front door access, by sending
 specific transactions from the initiating master (corresponding to port_id)
 and peer masters. Please look up the documentation of
 <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_cleanshared_sequence.html"> svt_axi_ace_master_cleanshared_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates CleanShared transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. CleanShared transactions can
 be sent only when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending CleanShared transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_cleanunique_sequence.html"> svt_axi_ace_master_cleanunique_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates CleanUnique transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. CleanUnique transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending CleanUnique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_cleanunique_sequential_sequence.html"> svt_axi_ace_master_cleanunique_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of CLEANUNIQUE transactions to consecutive address locations
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. 
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_evict_sequence.html"> svt_axi_ace_master_evict_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates Evict transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. Evict transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending Evict transactions, cachelines of masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_evict_sequential_sequence.html"> svt_axi_ace_master_evict_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of EVICT transactions to consecutive address locations
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. 
 #- A sequence of MAKEUNIQUE and WRITECLEAN transactions are sent prior to
 sending the EVICT transactions so that the cachelines are in Unique
 Clean State.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_exclusive_access_virtual_sequence.html"> svt_axi_ace_master_exclusive_access_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Basic Exclusive access sequeance
 This Sequence provides ACE Exclusive access at system level and can be used in any AXI_ACE master port to
 initiate Exclusive access transaction sequence using this.
<br>
 Transaction Sequences Used: Exclusive Load followed by Exclusive store 

<ul><li>
 Initialize cache lines if initialize_cachelines bit is set 

</li><li>
 Issue READCLEAN or READSHARED to load location and wait for the transaction to end

</li><li>
 Check the cache line state

<ul><li>
 if in Shared state issue CLEANUNIQUE 

</li><li>
 if in Invalid state then restart Exclusive Access

</li><li>
 else do nothing as Master can store directly to the cacheline no need to inform Interconnect

</li></ul>


</li><li>
 Stored data is updated to memory through WRITEBACK transaction

</li></ul>

<br>
 Please note, for generation of exclusive access transactions, svt_axi_port_configuration :: exclusive_access_enable 
 should be set for the targeted master and svt_axi_port_configuration :: speculative_read_enable should be set to zero
 for that master as well<br>
 <br> </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_exclusive_access_virtual_sequence.html#item_init_cachelines">init_cachelines<div>Description-Unavailable</div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_exclusive_access_virtual_sequence.html#item_ace_exclusive_select">ace_exclusive_select<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_makeinvalid_sequence.html"> svt_axi_ace_master_makeinvalid_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates MakeInvalid transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. MakeInvalid transactions can
 be sent only when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending MakeInvalid transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_makeunique_sequence.html"> svt_axi_ace_master_makeunique_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates MakeUnique transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. MakeUnique transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending Makeunique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_makeunique_sequential_sequence.html"> svt_axi_ace_master_makeunique_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of MAKEUNIQUE transactions to consecutive address locations
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port should be an ACE port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_readclean_sequence.html"> svt_axi_ace_master_readclean_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates ReadClean transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. ReadClean transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending ReadClean transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_readnosnoop_sequence.html"> svt_axi_ace_master_readnosnoop_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates ReadNoSnoop transaction from the ACE/ACE_LITE
 master specified with port_id , which can be a random port or a specific
 port configured by the user through uvm_config_db.  </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_readnotshareddirty_sequence.html"> svt_axi_ace_master_readnotshareddirty_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates ReadNotSharedDirty transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. ReadNotSharedDirty transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending ReadNotSharedDirty transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_readonce_sequence.html"> svt_axi_ace_master_readonce_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates ReadOnce transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. ReadOnce transactions can be
 sent only when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending ReadOnce transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_readshared_sequence.html"> svt_axi_ace_master_readshared_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates Readshared transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. ReadShared transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending Readshared transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_readunique_sequence.html"> svt_axi_ace_master_readunique_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates ReadUnique transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. ReadUnique transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending ReadUnique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_read_type_shareable_region_sequential_sequence.html"> svt_axi_ace_master_read_type_shareable_region_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of shareable read transactions to consecutive address locations
 #- Shareable read transactions can be READONCE, READCLEAN, READNOTSHAREDDIRTY, READSHARED
 or READUNIQUE. The weights for these transactions can be passed through uvm_config_db.
 The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. If the port is an ACE-Lite port, only READONCE transactions
 are sent. All transactions sent are cacheline size transactions.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writeback_sequence.html"> svt_axi_ace_master_writeback_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates WriteBack transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. WriteBack transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending WriteBack transactions, cachelines of masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writeback_writeclean_sequential_sequence.html"> svt_axi_ace_master_writeback_writeclean_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of WRITEBACK/WRITECLEAN transactions to consecutive address locations
 #- The weights for these transactions can be passed through uvm_config_db.
 The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. 
 #- A sequence of MAKEUNIQUE transactions are sent prior to sending the WRITEBACK transactions
 so that the cachelines are in Unique Dirty State.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writeclean_sequence.html"> svt_axi_ace_master_writeclean_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates WriteClean transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. WriteClean transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending WriteClean transactions, cachelines of masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writeevict_sequence.html"> svt_axi_ace_master_writeevict_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates WriteEvict transaction from the ACE master specified
 with port_id , which can be a random port or a specific port configured by
 the user through uvm_config_db. WriteEvict transactions can be sent only
 when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the master
 corresponding to port_id is set to <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a>.
 Before sending WriteEvict transactions, cachelines of masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writeevict_sequential_sequence.html"> svt_axi_ace_master_writeevict_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of WRITEEVICT transactions to consecutive address locations
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port must be an ACE port and must have 
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_writeevict_enable">writeevict_enable</a> set.
 #- A sequence of MAKEUNIQUE and WRITECLEAN transactions are sent prior to
 sending the WRITEEVICT transactions so that the cachelines are in Unique
 Clean State.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writelineunique_sequence.html"> svt_axi_ace_master_writelineunique_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates WriteLineUnique transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. WriteLineUnique transactions can
 be sent only when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending WriteLineUnique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writenosnoop_readnosnoop_sequential_sequence.html"> svt_axi_ace_master_writenosnoop_readnosnoop_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of writenosnoop transactions to consecutive address locations
 #- Wait for all writenosnoop transactions to complete. <br>
 #- Send a sequence of readnosnoop transactions to the same set of addresses
 targetted by the writenosnoop transactions. <br>
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writenosnoop_sequence.html"> svt_axi_ace_master_writenosnoop_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates WriteNoSnoop transaction from the ACE/ACE_Lite
 master specified with port_id , which can be a random port or a specific
 port configured by the user through uvm_config_db.  </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writeunique_sequence.html"> svt_axi_ace_master_writeunique_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initiates WriteUnique transaction from the ACE/ACE-Lite master
 specified with port_id , which can be a random port or a specific port
 configured by the user through uvm_config_db. WriteUnique transactions can
 be sent only when the <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_axi_interface_type">axi_interface_type</a> of the
 master corresponding to port_id is set to
 <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_AXI_ACE">AXI_ACE</a> or <a class="ClassLink" href="class_svt_axi_port_configuration.html">svt_axi_port_configuration</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_port_configuration.html#item_ACE_LITE">ACE_LITE</a>.
 Before sending WriteUnique transactions, cachelines of peer masters are
 initialized to random, valid states. Initialisation is done through front
 door access, by sending specific transactions from the initiating master
 (corresponding to port_id) and peer masters. Please look up the
 documentation of <a class="ClassLink" href="class_svt_axi_cacheline_initialization.html">svt_axi_cacheline_initialization</a>
 for details. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_writeunique_writelineunique_sequential_sequence.html"> svt_axi_ace_master_writeunique_writelineunique_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Send a sequence of WRITEUNIQUE/WRITELINEUNIQUE transactions to consecutive address locations
 #- The weights for these transactions can be passed through uvm_config_db.
 #- The port on which the transactions are sent sent are determined by port_id which can
 be passed via config_db. The port can be ACE or ACE-Lite port.
 #- The start address of the sequence can be passed through a uvm_config_db for 'start_addr'
 If no start_addr is passed, the address of the first transaction randomized in the sequence
 is taken as the start address of the sequence. <br> </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_random_exclusive_access_virtual_sequence.html"> svt_axi_ace_random_exclusive_access_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Creates system wide random exclusive access sequence on ACE ports.
 Scenarios which are covered are as follows: </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_random_exclusive_access_virtual_sequence.html#item_init_cachelines">init_cachelines<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_two_port_base_virtual_sequence.html"> svt_axi_ace_master_two_port_base_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Base class from which all ACE intermediate level sequences will be extended.  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_two_port_base_virtual_sequence.html#item_first_port_id">first_port_id<div>Represents the first master port. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_two_port_base_virtual_sequence.html#item_second_port_id">second_port_id<div>Represents the second master port. </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_two_port_base_virtual_sequence.html#item_two_port_interface_type">two_port_interface_type<div>The interface types for the first port and second port </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_overlapping_addr_sequence.html"> svt_axi_ace_master_overlapping_addr_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence attempts to create a scenario where random coherent
 transactions targetting the same address are initiated from two different
 masters in which one is an ACE master specified with first_port_id and 
 another one is an ACE/ACE_LITE master specified through second_port_id.
 If second_port_xact_type is <a class="ClassLink" href="class_svt_axi_transaction.html">svt_axi_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_transaction.html#item_WRITENOSNOOP">WRITENOSNOOP</a> then the
 transactions will not be sent to same addresses as transactions from first_port_id, 
 but the transactions will be fired concurrently from the masters. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_overlapping_addr_sequence.html#item_first_port_xact_type">first_port_xact_type<div>Random coherent transaction type for coherent_seq_first_port </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_overlapping_addr_sequence.html#item_second_port_xact_type">second_port_xact_type<div>Random coherent transaction type for coherent_seq_second_port </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_read_during_coherent_write_sequence.html"> svt_axi_ace_master_read_during_coherent_write_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence sends coherent read transactions while sending coherent write
 transactions to the same address from another port. In most cases, the
 interconnect will have to refetch data from the memory, if none of the
 snoops returned data. This is because the first read may return data that
 is not being written through the coherent write transaction depending on
 whether the data reached the slave. Hence a second read will have to be
 issued to ensure that the latest data is available. The sequence creates a
 scenario where the interconnect is forced to refetch data from memory  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_read_during_coherent_write_sequence.html#item_second_port_xact_type">second_port_xact_type<div>Random coherent transaction type for coherent_seq_second_port </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_read_during_coherent_write_sequence.html#item_domain_type">domain_type<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_snoop_during_memory_update_sequence.html"> svt_axi_ace_master_snoop_during_memory_update_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence attempts to create a scenario where an initiating master
 (given by first_port_id) receives a snoop to the same cacheline while
 transmitting a WRITEBACK, WRITECLEAN, WRITEEVICT or EVICT
 (referred to as memory update transactions). The relative
 weights of WRITEBACK,WRITECLEAN,WRITEEVICT or EVICT can be
 set by passing writeback_wt,writeclean_wt,writeevict_wt and evict_wt
 respectively, through the UVM/OVM configuration infrastructure.
 By default, WRITEBACK and WRITECLEAN transactions have a weight of 1
 while the other transactions have a weight of 0.
 The scenario first initializes cachelines to valid states
 before sending memory update transactions. Based on the kind of
 transaction sent, the following initial states are reached after
 cacheline initialization.
 WRITEBACK,WRITECLEAN: Unique Dirty.
 WRITEEVICT, EVICT: Unique Clean. 
  .
 The coherent transactions that can be sent from second_port_id are

<ul><li>
 CMO : MAKEINVALID, CLEANINVALID or CLEANSHARED
 STORE : MAKEUNIQUE, CLEANUNIQUE, READUNIQUE, WRITEUNIQUE or WRITELINEUNIQUE
 LOAD : READONCE, READSHARED, READCLEAN or READNOTSHAREDDIRTY.
 In case of CLEANUNIQUE the initial state must be shared state.(if cleanunique_wt is 1)
 After completing initialisation for memory update, readshared will be sent from 
 second_port_id to initialize the states to shared, for the cleanunique addresses.

</li></ul>

 If addr_mode_select is set from test, the sequence will fire memory update 
 transactions from first_port_id and coherent transactions from second_port_id
 to the same set of sequential addresses at the same time.
 If addr_mode_select is low, the sequence will fire memory update 
 transactions from first_port_id and coherent transactions from second_port_id
 to the same set of random addresses at the same time.
  .
 The combination of WRITEEVICT and CLEANUNIQUE cant be exercised because
 Initial state of WRITEEVICT must be Unique Clean,for CLEANUNIQUE any shared state
 so at the same time the states cant be in unique and shared.  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_snoop_during_memory_update_sequence.html#item_second_port_xact_type">second_port_xact_type<div>Random coherent transaction type for second_port_id </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_two_master_concurrent_write_sequence.html"> svt_axi_ace_master_two_master_concurrent_write_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence sends cocurrent write transactions from two ports after initializing cache lines </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_two_master_concurrent_write_sequence.html#item_second_port_xact_type">second_port_xact_type<div>Random coherent transaction type for coherent_seq_second_port </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_two_port_base_sequential_virtual_sequence.html"> svt_axi_ace_master_two_port_base_sequential_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Base class from which all virtual sequences for sequential accesses to overlapping addresses are extended </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ace_master_two_port_base_sequential_virtual_sequence.html#item_first_port_xact_category">first_port_xact_category<div>The transaction category for the first port </div></a>
<br><a class="inhlist" href="class_svt_axi_ace_master_two_port_base_sequential_virtual_sequence.html#item_second_port_xact_category">second_port_xact_category<div>The transaction category for the second port </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_two_port_overlapping_addr_cmo_and_store_sequential_sequence.html"> svt_axi_ace_master_two_port_overlapping_addr_cmo_and_store_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends a set of concurrent, sequential cmo accesses from first_port_id and store
 accesses from second_port_id to the same set of overlapping addresses. 
 CMO type transactions can be MAKEINVALID, CLEANINVALID
 or CLEANSHARED.The store type transactions can be MAKEUNIQUE, READUNIQUE, CLEANUNIQUE,
 WRITEUNIQUE or WRITELINEUNIQUE based on the interface types of the ports and the weights.
 an initialisation procedure is invoked based on the following sequence, unless
 Prior to sending the cmo and store transaction bypass_cache_initialisation is set:

<ul><li>
 In order that the store transactions can be fired from various initial states. 

</li></ul>


<ul><li>
 If second_port_cleanunique_wt is not zero, cachelines are
 initialised, since CLEANUNIQUE can be sent only from a cacheline in shared
 state. Only cachelines from which CLEANUNIQUE needs to be sent are
 initialized. The number of CLEANUNIQUE transactions sent are determined by
 the formula sequence_length*first_port_cleanunique_wt/(sum of weights of
 all xact types in second port). Initialisation is done by sending
 MAKEUNIQUE transactions from one ACE port and READSHARED transactions from
 another ACE port to the same set of addresses. Snoop transactions for
 READSHARED type snoop are programmed (in the corresponding tests) to always
 assert <a class="ClassLink" href="class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_snoop_transaction.html#item_snoop_resp_datatransfer">snoop_resp_datatransfer</a> and
 <a class="ClassLink" href="class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_snoop_transaction.html#item_snoop_resp_isshared">snoop_resp_isshared</a> so that a shared state of
 the cacheline can be acheived in both masters. All shared cachelines in
 first_port_id are invalidated so that the cmo transactions can be sent on
 the interface. 

</li></ul>

 After this initialisation, sequential cmo access from first_port_id and
 sequential store from second_port_id are sent.
 .
 Sometimes if the cmo transactions snoops the second_port firstly and
 second port transaction is CLEANUNIQUE transaction means, there is a chance of
 invalidation of the cache line of second_port. By the result of this scenario
 the second_port may drop the CLEANUNIQUE transactions, Because CLEANUNIQUE
 cant be sent from INVALID state. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_two_port_overlapping_addr_load_cmo_sequential_sequence.html"> svt_axi_ace_master_two_port_overlapping_addr_load_cmo_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends a set of concurrent, sequential load or cmo accesses from first_port_id and
 load or cmo accesses from second_port_id based on the interface types of the 
 ports and the weights selected from corresponding tests to the same set 
 of overlapping addresses. Load type transactions can be READONCE, READCLEAN, READSHARED
 or READNOTSHAREDDIRTY. cmo type transactions can be MAKEINVALID, CLEANINVALID
 and CLEANSHARED. Prior to sending the load transaction an
 initialisation procedure is invoked based on the following sequence, unless
 bypass_cache_initialisation is set:

<ul><li>
 In order that the load transactions return some valid data,
 incase of ACE port MAKEUNIQUE followed by WRITEBACK are sent to update memory. 
 incase of ACE_LITE port WRITELINEUNIQUE transactions are sent to update memory. 

</li></ul>

 After this initialisation, sequential load or sequential cmo from first_port_id and
 sequential load or sequential cmo from second_port_id are sent concurrently to the same 
 set of addresses. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_two_port_overlapping_addr_store_and_load_sequential_sequence.html"> svt_axi_ace_master_two_port_overlapping_addr_store_and_load_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends a set of concurrent, sequential store accesses from first_port_id and load
 accesses from second_port_id to the same set of overlapping addresses. The
 store type transactions can be MAKEUNIQUE, READUNIQUE, CLEANUNIQUE,
 WRITEUNIQUE or WRITELINEUNIQUE based on the interface types of the ports
 and the weights. Load type transactions can be READONCE, READCLEAN,
 READSHARED or READNOTSHAREDDIRTY. Prior to sending the store and load transaction
 an initialisation procedure is invoked based on the following sequence, unless
 bypass_cache_initialisation is set:

<ul><li>
 In order that the load transactions return some valid data,
 WRITELINEUNIQUE transactions are sent to update memory. 

</li></ul>


<ul><li>
 If first_port_cleanunique_wt is not zero, cachelines are
 initialised, since CLEANUNIQUE can be sent only from a cacheline in shared
 state. Only cachelines from which CLEANUNIQUE needs to be sent are
 initialized. The number of CLEANUNIQUE transactions sent are determined by
 the formula sequence_length*first_port_cleanunique_wt/(sum of weights of
 all xact types in first port). Initialisation is done by sending
 MAKEUNIQUE transactions from one ACE port and READSHARED transactions from
 another ACE port to the same set of addresses. Snoop transactions for
 READSHARED type snoop are programmed (in the corresponding tests) to always
 assert <a class="ClassLink" href="class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_snoop_transaction.html#item_snoop_resp_datatransfer">snoop_resp_datatransfer</a> and
 <a class="ClassLink" href="class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_snoop_transaction.html#item_snoop_resp_isshared">snoop_resp_isshared</a> so that a shared state of
 the cacheline can be acheived in both masters. All shared cachelines in
 second_port_id are invalidated so that the load transactions can be sent on
 the interface. 

</li></ul>

 After this initialisation, sequential stores from first_port_id and
 sequential loads from second_port_id are sent. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ace_master_two_port_overlapping_addr_store_sequential_sequence.html"> svt_axi_ace_master_two_port_overlapping_addr_store_sequential_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Sends a set of concurrent, sequential store accesses from two ports to the
 same set of overlapping addresses. The store type transactions can be
 MAKEUNIQUE, READUNIQUE, CLEANUNIQUE, WRITEUNIQUE or WRITELINEUNIQUE based
 on the interface types of the ports and the weights. If
 first_port_cleanunique_wt or second_port_cleanunique_wt is not zero,
 cachelines are initialised since CLEANUNIQUE can be sent only from a
 cacheline in shared state. Only cachelines from which CLEANUNIQUE needs to
 be sent are initialized. The number of CLEANUNIQUE transactions sent are
 determined by the formula sequence_length*cleanunique_wt/(sum of weights of
 all xact types). Initialisation is done by sending MAKEUNIQUE transactions
 from one ACE port and READSHARED transactions from another ACE port to the
 same set of addresses. Snoop transactions for READSHARED type snoop are
 programmed (in the corresponding tests) to always assert
 <a class="ClassLink" href="class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_snoop_transaction.html#item_snoop_resp_datatransfer">snoop_resp_datatransfer</a> and
 <a class="ClassLink" href="class_svt_axi_snoop_transaction.html">svt_axi_snoop_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_snoop_transaction.html#item_snoop_resp_isshared">snoop_resp_isshared</a> so that a shared state of
 the cacheline can be acheived in both masters. Once cachelines are
 initialised, sequential stores from first_port_id and second_port_id are
 made. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_cacheline_initialization.html"> svt_axi_cacheline_initialization </a> </td>
<td class="MemberListLeft" valign="center" > This sequence initializes the cache line of all masters.
 This is done by:
 Initiating MakeUnique from 'initiating masters sequencer'
 Initiating Writeclean for some cachelines of masters.
 Initiating ReadShared from rest of ports that are ACE. 
 If use_parent_sequence_params is set, this sequence initializes all
 the addresses of transactions in the parent sequence. If not set,
 it initializes the address given in init_addr </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_cacheline_invalidation.html"> svt_axi_cacheline_invalidation </a> </td>
<td class="MemberListLeft" valign="center" > This sequence invalidates the cache line of a master.
 It checks the state of the cache line and initiaties the appropriate transaction
 If the cacheline state is dirty, a WRITEBACK is initiated.
 If the cacheline state is clean, an EVICT is initiated. </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_burst_aligned_addr_full_data_width_random_ictest_sequence.html"> svt_axi_burst_aligned_addr_full_data_width_random_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive random transactions with burst size<br>
 (AxSIZE) equal to data width of AXI bus, aligned address and all other control<br> 
 fields generated randomly.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_burst_aligned_addr_full_data_width_random_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_burst_aligned_addr_narrow_transfers_random_ictest_sequence.html"> svt_axi_burst_aligned_addr_narrow_transfers_random_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive random transactions with narrow transfers,<br>
 aligned address and all other control fields generated randomly.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_burst_aligned_addr_narrow_transfers_random_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_burst_unaligned_addr_full_data_width_random_ictest_sequence.html"> svt_axi_burst_unaligned_addr_full_data_width_random_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive random transactions with burst size<br>
 (AxSIZE) equal to data width of AXI bus, unaligned address and all other<br>
 control fields generated randomly.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_burst_unaligned_addr_full_data_width_random_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_burst_unaligned_addr_narrow_transfers_random_ictest_sequence.html"> svt_axi_burst_unaligned_addr_narrow_transfers_random_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive random transactions with narrow transfers,<br>
 unaligned address and all other control fields generated randomly.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_burst_unaligned_addr_narrow_transfers_random_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_burst_write_data_before_address_ictest_sequence.html"> svt_axi_burst_write_data_before_address_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive Write transaction with Write data in <br> 
 Write Data Channel first, followed by Address on the Write Adderss <br> 
 Channel.<br> 
 #- Check Interconnect forwards the Write transaction to Slave VIP properly.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all<br> 
 the Slaves connected to the IC DUT.<br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_burst_write_data_before_address_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_burst_write_read_with_zero_delay_ictest_sequence.html"> svt_axi_burst_write_read_with_zero_delay_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the testbench to drive ARESETn from LOW to HIGH<br> 
 #- Program the Master VIP to drive Write/Read transaction in Write/Read <br> 
 Address/Data channel on the immediate active edge of ACLK after ARESETn <br> 
 becoming HIGH <br> 
 #- Wait for the transaction to complete successfully. <br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_burst_write_read_with_zero_delay_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_burst_write_with_strobe_deasserted_ictest_sequence.html"> svt_axi_burst_write_with_strobe_deasserted_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive write transcation with all strobes = 1.<br> 
 This will initialize the memory to a known value.<br> 
 #- Program the Master VIP to drive write transcation to the same location<br> 
 of previous write transaction with all strobe bits = 0 for certain transfers. <br> 
 #- Program the Master VIP to drive Read transaction. <br> 
 #- Check the read data and compare it with write data (expected data).<br> 
 #- Initiate the above stimulus from all Master VIPs towards all the Slaves <br> 
 connected to the IC DUT.<br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_burst_write_with_strobe_deasserted_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_decode_error_response_ictest_sequence.html"> svt_axi_decode_error_response_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive Write/Read transaction. Configure the<br> 
 Master transaction such that it should fire a transaction having address<br> 
 which doesn't fall in any of the slaves. To determine an address which <br> 
 would issue DECERR, address map in system configuration will need to be<br> 
 referred.<br> 
 #- Check Interconnect responds with DECERR.<br>
 #- Initiate the above stimulus from all Master VIPs.<br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_decode_error_response_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_decode_error_response_ictest_sequence.html#item_dec_addr">dec_addr<div>Decode address in used to constrain the decode address in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_exclusive_normal_random_virtual_sequence.html"> svt_axi_exclusive_normal_random_virtual_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive multiple transaction with randomly
 selected atomic type of Exclusive or Normal read transaction
 Program the Master VIP to wait for previous Exclusive or Normal
 transaction to end
 All other control fields are generated randomly. </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_exclusive_normal_random_virtual_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_exclusive_read_write_ictest_sequence.html"> svt_axi_exclusive_read_write_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive Exclusive read transaction followed by <br>
 Exclusive write transaction with same control fields as previous<br> 
 Exclusive read and all other control fields generated randomly.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_exclusive_read_write_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_locked_read_followed_by_excl_sequence.html"> svt_axi_locked_read_followed_by_excl_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive Locked read transaction followed by <br>
 Exclusive read transaction with same control fields as previous<br> 
 lock read and all other control fields generated randomly.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_locked_read_followed_by_excl_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_read_same_id_from_diff_masters_ictest_sequence.html"> svt_axi_ordering_read_same_id_from_diff_masters_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a randomly selected Master M0 VIP to drive a read transaction<br> 
 to the Slave VIP .<br>
 #- Program the Slave VIP to suspend the response of read transaction from Master<br>
 M0 VIP.Use <a class="ClassLink" href="class_svt_axi_transaction.html">svt_axi_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_transaction.html#item_suspend_response">suspend_response</a> member to suspend the response.<br>
 Use it in slave response sequence.<br>
 #- Program another randomly selected Master M1 VIP to drive a read transaction to<br> 
 the same Slave VIP.Wait for transaction from M1 to end.<br>
 #- Release the suspended response from Slave VIP for read transaction from Master<br> 
 M0 VIP.<br>
    .  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_read_same_id_from_diff_masters_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_ordering_read_same_id_from_diff_masters_ictest_sequence.html#item_selected_mstr">selected_mstr<div>Variables to select random Masters </div></a>
<br><a class="inhlist" href="class_svt_axi_ordering_read_same_id_from_diff_masters_ictest_sequence.html#item_initiating_master_index_2">initiating_master_index_2<div>Variables to select random Masters </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_read_write_same_id_ictest_sequence.html"> svt_axi_ordering_read_write_same_id_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive read transaction.<br>
 #- After few clock cycles, program the Master VIP to drive write transaction<br> 
 to Slave VIP with AWID same as ARID.<br>
 #- Program the Slave VIP to delay the response of previous read transaction.<br>
 #- Check interconnect forwards the response of write transaction and then response<br>
 of read transaction.<br>
    .  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_read_write_same_id_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_same_id_xact_from_diff_masters_ictest_sequence.html"> svt_axi_ordering_same_id_xact_from_diff_masters_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Drive a sequence of Write transactions with same AWID to the same Slave VIP<br> 
 from all masters simultaneously.<br> 
 #- Wait for all Write transactions to complete.<br>
 #- Drive a sequence of Read transactions with same ARID to the same Slave VIP<br>
 from all masters simultaneously.<br> 
 #- Program the Slave VIP to interleave read data.<br>
 #- Check that the Interconnect is forwarding the correct read data with respect to<br>
 address issued,to the appropriate Master.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_same_id_xact_from_diff_masters_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_overlap_addr_same_id_device_memory_ictest_sequence.html"> svt_axi_ordering_write_overlap_addr_same_id_device_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the AXI Master VIP to drive multiple (4) write transactions for same<br> 
 Slave VIP with same ID, different (but overlapping) AWADDR to Device memory.<br> 
 #- Make sure addresses in the transactions are overlapping. This will help to <br> 
 validate that ordering is preserved for overlapping addresses for Device Memory.<br>
 #- Check the write transactions are in same order at the Interconnect Master Port<br> 
 and Interconnect Slave Port. Also check the IDs of all transactions at the<br> 
 Interconnect Master port are same.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves connected to the Interconnect DUT.<br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_overlap_addr_same_id_device_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_device_memory_diff_slave_response_ictest_sequence.html"> svt_axi_ordering_write_read_same_id_device_memory_diff_slave_response_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive two write transactions to two randomly selected<br> 
 slave, with non-repetitive data (incremental, random)<br>
 #- Program the Master VIP to drive two read transactions to same randomly selected<br> 
 Slave VIPs, with same ARID. Use the same address for read transactions as used<br> 
 by write transactions.<br>
 #- Check the RDATA are in same order at Interconnect Slave Port. This will be<br> 
 checked by data_integrity check in AXI System Monitor.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves connected to the Interconnect DUT<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_device_memory_diff_slave_response_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_device_memory_diff_slave_response_ictest_sequence.html#item_participating_slave_index_2">participating_slave_index_2<div>Variable to select random slaves </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_device_memory_ictest_sequence.html"> svt_axi_ordering_write_read_same_id_device_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Description-Unavailable </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_device_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_device_memory_same_slave_response_ictest_sequence.html"> svt_axi_ordering_write_read_same_id_device_memory_same_slave_response_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive two write transactions to the same slave,<br> 
 with non-repetitive data (incremental, random)<br>
 #- Program the Master VIP to drive two read transactions for same Slave with<br>
 same ARID. Use the same address for read transactions as used by write<br>
 transactions.<br>
 #- Check the RDATA are in same order at Interconnect Slave Port. This will be<br>
 checked by data_integrity check in AXI System Monitor.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves connected to the Interconnect DUT<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_device_memory_same_slave_response_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_memory_ictest_sequence.html"> svt_axi_ordering_write_same_id_device_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the AXI Master VIP to drive multiple (4) write transactions<br> 
 for same Slave VIP with same ID, different AWADDR to Device memory.<br> 
 #- Make sure addresses in the transactions are non-overlapping. This will<br> 
 help to validate that ordering is preserved even for non-overlapping addresses<br>
 for Device Memory.<br>
 #- Check the write transactions are in same order at the Interconnect Master Port<br> 
 and Interconnect Slave Port. Also check the IDs of all transactions at the<br> 
 Interconnect Master port are same.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br>
 Slaves connected to the Interconnect DUT.<br>
    .  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_slave_response_ictest_sequence.html"> svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_slave_response_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a Master VIP to drive two normal write transactions to two different<br>
 randomly selected Slave VIPs and with same AWID.Program AWCACHE[1:0] to 2'b00,<br>
 to indicate non-modifiable, non-bufferable. This ensures that both write<br> 
 transactions reach the Slave VIP.<br>
 #- Program the Slave VIP to respond to first transaction with OKAY and second <br>
 transaction with SLVERR. Program the delays such that response to second write<br>
 transaction is sent first, that is, before response for first write transaction.<br>
 #- Check the BRESP are in same order at Interconnect Master Port. This will be <br>
 checked in the master sequence itself. Check that the response of the first <br>
 completed transaction is OKAY. Check that the response of second transaction <br>
 is SLVERR.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br>
 Slaves connected to the Interconnect DUT.<br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_slave_response_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_slave_response_ictest_sequence.html#item_active_participating_slave_index_2">active_participating_slave_index_2<div>Variable to select random slaves </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_same_slave_response_ictest_sequence.html"> svt_axi_ordering_write_same_id_device_non_bufferable_memory_same_slave_response_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a Master VIP to drive two normal write transactions to same Slave VIP <br>
 and with same AWID.Program AWCACHE[1:0] to 2'b00, to indicate non-modifiable,<br> 
 non-bufferable. This ensures that both Write transactions reach the Slave VIP.<br>
 #- Program the Slave VIP to respond to first transaction with OKAY and second<br> 
 transaction with SLVERR. Program random delays in the slave responses.<br>
 #- Check the BRESP are in same order at Interconnect Master Port. This will be <br>
 checked in the master sequence itself. Check that the response of the first <br>
 completed transaction is OKAY. Check that the response of second transaction <br>
 is SLVERR.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all <br>
 the Slaves connected to the Interconnect DUT.<br> </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_same_slave_response_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_random_all_master_to_all_slave_sequence.html"> svt_axi_random_all_master_to_all_slave_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive multiple random transaction to each Slave.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all<br>
 the Slaves connected to the IC DUT.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_random_all_master_to_all_slave_sequence.html#item_sequence_length">sequence_length<div>Description-Unavailable</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_random_ictest_sequence.html"> svt_axi_random_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive multiple random transaction.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_random_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_signal_timing_write_read_default_ready_ictest_sequence.html"> svt_axi_signal_timing_write_read_default_ready_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive Write and read transactions.<br> 
 #- Configure the Master and Slave VIP default values of READY signal from
 the test.<br> 
 #- Check the Interconnect Master Port is driving VALID irrespective of READY <br> 
 from Slave. This will get tested through system configuration <br> 
 bus_inactivity_timeout.<br> 
 #- Initiate the above stimulus from all Master VIPs towards all the Slaves <br> 
 connected to the IC DUT.<br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_signal_timing_write_read_default_ready_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_system_random_sequence.html"> svt_axi_system_random_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence allows unconstrained random traffic for all ports </td>
<td  valign="center" >  --  </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi3_random_read_write_locked_sequence.html"> svt_axi3_random_read_write_locked_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive random locked transaction <br>
 Send Exclusive transaction with same xact_type and addr as of locked transaction<br> 
 to unlock the locked sequence and all other control fields generated randomly.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi3_random_read_write_locked_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_device_non_bufferable_memory_ictest_sequence.html"> svt_axi_ordering_write_device_non_bufferable_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive write transaction with AWCACHE[1:0]=2'b00.<br>
 #- Check the transaction is not modified at the Interconnect Master Port.<br>
 #- Check Interconnect is not responding to the write transaction until Slave VIP<br>
 responds.<br>
 #- Wait for the transaction to complete successfully. <br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br>
 Slaves connected to the Interconnect DUT. <br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_device_non_bufferable_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_read_bufferable_memory_ictest_sequence.html"> svt_axi_ordering_write_read_bufferable_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive write transaction with AWCACHE[0]=1'b1.<br>
 Rest bits can be random.<br>
 #- After receiving write response, program the AXI Master VIP to drive read <br>
 transaction with same address as previous write with ARCACHE[3:0] as random.<br>
 #- Wait for the transaction to complete successfully. <br>
 #- Compare read data with write data.<br>
 #- Initiate the above stimulus from all Master VIPs sequentially towards all<br> 
 the Slaves connected to the Interconnect DUT.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_read_bufferable_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_diff_id_device_memory_ictest_sequence.html"> svt_axi4_ordering_read_overlap_addr_diff_id_device_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a randomly selected AXI4 Master VIP to drive two Read transactions to<br> 
 same Slave VIP with different ID and overlapping address (not same address).<br> 
 Select the address of first Read transaction randomly. Calculate the address<br> 
 for second Read transaction such that it is overlapping with address of first<br> 
 Read transaction. ARCACHE[1] should be set to 0, to indicate non-modifiable<br> 
 transactions(to device memory).<br> 
 #- Within the sequence, wait for xact_request_received_event event issued by Slave VIP Port monitor.<br> 
 Check if the address of the transaction which triggered this event is same as<br> 
 address of the first read transaction. This validates that the read addresses<br> 
 arrived at the Slave VIP in the same order in which they were issuesd by the<br> 
 Master VIP.<br> 
    .  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_diff_id_device_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_diff_id_device_memory_ictest_sequence.html#item_supporting_master_index">supporting_master_index<div>Supporting Master index *</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_diff_id_normal_memory_ictest_sequence.html"> svt_axi4_ordering_read_overlap_addr_diff_id_normal_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a randomly selected AXI4 Master VIP to drive two Read transactions to<br> 
 same Slave VIP with different ID and overlapping address (not same address).<br> 
 Select the address of first Read transaction randomly. Calculate the address<br> 
 for second Read transaction such that it is overlapping with address of first<br> 
 Read transaction. ARCACHE[1] should be set to 1, to indicate modifiable transactions<br>
 #- Within the sequence, wait for xact_request_received_event event issued by Slave VIP Port monitor.<br> 
 Check if the address of the transaction which triggered this event is same as<br> 
 address of the first read transaction. This validates that the read addresses<br> 
 arrived at the Slave VIP in the same order in which they were issued by the Master VIP.<br> 
    .  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_diff_id_normal_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_diff_id_normal_memory_ictest_sequence.html#item_supporting_master_index">supporting_master_index<div>Supporting Master index *</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_same_id_device_memory_ictest_sequence.html"> svt_axi4_ordering_read_overlap_addr_same_id_device_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a randomly selected AXI4 Master VIP to drive two Read transactions to<br> 
 same Slave VIP with same ID and overlapping address (not same address).<br> 
 Select the address of first Read transaction randomly. Calculate the address<br> 
 for second Read transaction such that it is overlapping with address of first<br> 
 Read transaction. ARCACHE[1] should be set to 0, to indicate non-modifiable<br> 
 transactions(to device memory).<br>
 #- Within the sequence, wait for xact_request_received_event event issued by Slave VIP Port monitor.<br> 
 Check if the address of the transaction which triggered this event is same as<br> 
 address of the first read transaction. This validates that the read addresses<br> 
 arrived at the Slave VIP in the same order in which they were issuesd by the<br> 
 Master VIP.<br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_same_id_device_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_same_id_device_memory_ictest_sequence.html#item_supporting_master_index">supporting_master_index<div>Supporting Master index *</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_same_id_normal_memory_ictest_sequence.html"> svt_axi4_ordering_read_overlap_addr_same_id_normal_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a randomly selected AXI4 Master VIP to drive two Read transactions to<br> 
 same Slave VIP with same ID and overlapping address (not same address).<br> 
 Select the address of first Read transaction randomly. Calculate the address<br> 
 for second Read transaction such that it is overlapping with address of first<br> 
 Read transaction. ARCACHE[1] should be set to 1, to indicate modifiable transactions<br>
 #- Within the sequence, wait for xact_request_received_event event issued by Slave VIP Port monitor.<br> 
 Check if the address of the transaction which triggered this event is same as<br> 
 address of the first read transaction. This validates that the read addresses<br> 
 arrived at the Slave VIP in the same order in which they were issued by the Master VIP.<br> 
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_same_id_normal_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi4_ordering_read_overlap_addr_same_id_normal_memory_ictest_sequence.html#item_supporting_master_index">supporting_master_index<div>Supporting Master index *</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi4_ordering_write_overlap_addr_diff_id_device_memory_ictest_sequence.html"> svt_axi4_ordering_write_overlap_addr_diff_id_device_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the AXI Master VIP to drive multiple (4) write transactions for<br> 
 same Slave VIP with different ID, different (but overlapping) AWADDR to<br>
 Device memory.<br> 
 #- Make sure addresses in the transactions are overlapping.This will help to<br> 
 validate that ordering is preserved for overlapping addresses for Device<br>
 Memory.<br>
 #- Check the write transactions are in same order at the Interconnect Master Port<br>
 and Interconnect Slave Port.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves connected to the Interconnect DUT<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi4_ordering_write_overlap_addr_diff_id_device_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi4_ordering_write_overlap_addr_diff_id_normal_memory_ictest_sequence.html"> svt_axi4_ordering_write_overlap_addr_diff_id_normal_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the AXI Master VIP to drive multiple (4) write transactions for<br> 
 same Slave VIP with different ID, different (but overlapping) AWADDR to<br> 
 Normal memory.<br> 
 #- Make sure addresses in the transactions are overlapping. This will help to<br>
 validate that ordering is preserved for overlapping addresses for Normal Memory.<br>
 #- Check the write transactions are in same order at the Interconnect Master Port<br> 
 and Interconnect Slave Port.<br>
 #- Wait for the transaction to complete successfully.<br> 
 #- Initiate the above stimulus from all Master VIPs sequentially towards all the<br> 
 Slaves_connected to the Interconnect DUT.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi4_ordering_write_overlap_addr_diff_id_normal_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi4_ordering_write_overlap_addr_same_id_normal_memory_ictest_sequence.html"> svt_axi4_ordering_write_overlap_addr_same_id_normal_memory_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a randomly selected AXI4 Master VIP to drive two write transactions to<br> 
 same Slave VIP with same ID and overlapping address (not same address).<br> 
 Select the address of first write transaction randomly. Calculate the address<br> 
 for second write transaction such that it is overlapping with address of first<br> 
 write transaction. AWCACHE[1] should be set to 1, to indicate modifiable<br> 
 transactions.<br> 
 #- Wait for both the write transactions to end.<br>
 #- Program the AXI4 Master VIP to drive a read transaction to the same address as<br> 
 the second write transaction.<br>
 #- Compare the read data with data of second write transaction, which is the<br> 
 expected data.<br>
 #- Disable the data_integrity check as this check can falsely fire in case of<br> 
 outstanding transactions to same or overlapping address.<br> </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi4_ordering_write_overlap_addr_same_id_normal_memory_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi4_ordering_write_overlap_addr_same_id_normal_memory_ictest_sequence.html#item_supporting_master_index">supporting_master_index<div>Supporting Master index *</div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_ictest_sequence.html"> svt_axi_ordering_write_read_same_id_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive write transaction.<br>
 #- After few clock cycles, program the Master VIP to drive read transaction to<br> 
 Slave VIP with ARID same as AWID.<br>
 #- Program the Slave VIP to delay the response of previous write transaction.<br>
 #- Check interconnect forwards the response of read transaction and then response<br> 
 of write transaction.This will get tested through system configuration<br>
 bus_inactivity_timeout.<br>
    .  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_sequence_diff_masters_ictest_sequence.html"> svt_axi_ordering_write_read_same_id_sequence_diff_masters_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Drive a sequence of Write transactions with a set of different AWID's to the<br>
 same Slave VIP(e.g sequence of IDs 1,2,3,4,5 from each Master) from all<br> 
 masters simultaneously.<br> 
 Note that the set of AWIDs used must remain same for all Masters.<br>
 #- Wait for all Write transactions to complete.<br>
 #- Drive a sequence of Read transactions with a set of different ARID's to the<br>
 same Slave VIP(e.g sequence of IDs 1,2,3,4,5 from each Master) from all<br> 
 masters simultaneously.<br>
 Note that the set of ARIDs used must remain same for all Masters.<br>
 #- Program the Slave VIP to interleave read data.<br>
 #- Check that the Interconnect is forwarding the correct read data with respect to<br> 
 address issued,to the appropriate Master.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_read_same_id_sequence_diff_masters_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_read_without_wait_ictest_sequence.html"> svt_axi_ordering_write_read_without_wait_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master VIP to drive write transaction to Slave VIP.<br>
 #- Program the Slave VIP to delay the response of previous write transaction<br> 
 until further intimation.<br>
 #- Program the Master VIP to drive read transaction to the same Slave VIP before<br>
 getting response to above write transaction.<br>
 #- Check that the Interconnect is forwarding the read transaction before receiving<br>
 response from Slave VIP.This will get tested through system configuration<br>
 bus_inactivity_timeout.<br>
 #- Program the Slave VIP to respond to both read and write transactions.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_read_without_wait_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_same_id_from_diff_masters_ictest_sequence.html"> svt_axi_ordering_write_same_id_from_diff_masters_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program a randomly selected Master M0 VIP to drive a write transaction to<br> 
 the Slave VIP .<br>
 #- Program the Slave VIP to suspend the response of write transaction from<br> 
 Master M0 VIP.<br>
 Use <a class="ClassLink" href="class_svt_axi_transaction.html">svt_axi_transaction</a> <b>::</b> <a class="ClassLink" href="class_svt_axi_transaction.html#item_suspend_response">suspend_response</a> member to suspend the response.<br>
 Use it in slave response sequence.<br>
 #- Program another randomly selected Master M1 VIP to drive a write transaction<br>
 to the same Slave VIP.Wait for transaction from M1 to end.<br>
 #- Release the suspended response from Slave VIP for write transaction from Master<br>
 M0 VIP.<br>
    .  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_same_id_from_diff_masters_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_ordering_write_same_id_from_diff_masters_ictest_sequence.html#item_selected_mstr">selected_mstr<div>Variables to select random Masters </div></a>
<br><a class="inhlist" href="class_svt_axi_ordering_write_same_id_from_diff_masters_ictest_sequence.html#item_initiating_master_index_2">initiating_master_index_2<div>Variables to select random Masters </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi3_ordering_write_diff_id_interleave_ictest_sequence.html"> svt_axi3_ordering_write_diff_id_interleave_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program all AXI3 Master VIPs to simultaneously drive a sequence of write<br> 
 transactions with interleaved write data(with write interleaving depth >1 )<br>
 with random AWID's. <br>
 Transaction address will be randomly selected based on system address map.<br>
 #- Configure the AXI3 Slave VIP interleaving depth >1.<br>
 #- Check that the Interconnect is forwarding the correct write data with respect<br>
 to address issued<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi3_ordering_write_diff_id_interleave_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi3_ordering_write_diff_id_interleave_with_repeating_id_ictest_sequence.html"> svt_axi3_ordering_write_diff_id_interleave_with_repeating_id_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program all AXI3 Master VIPs to simultaneously drive a sequence of write<br> 
 transactions with repeating AWID's (1,2,1,2,1). In case of master being<br> 
 configured as AXI3 write data with interleaving (with write interleaving<br> 
 depth >1).Transaction address will be randomly selected based on system<br> 
 address map.<br>
 #- Configure the AXI3 Slave VIP interleaving depth >1.<br>
 #- Check that the Interconnect is forwarding the correct write data with<br> 
 respect to address issued.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi3_ordering_write_diff_id_interleave_with_repeating_id_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi3_ordering_write_diff_id_no_interleave_at_slave_ictest_sequence.html"> svt_axi3_ordering_write_diff_id_no_interleave_at_slave_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Configure Master VIP to interleaving depth >1.<br>
 #- Program AXI3 Master VIP to drive a sequence of write transactions with write<br> 
 data interleaving.<br>
 #- Configure the AXI3 Slave VIP to interleaving depth of 1<br>
 #- Check that the Interconnect is forwarding the transactions to the AXI3 Slave<br> 
 VIP without write data interleaving<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi3_ordering_write_diff_id_no_interleave_at_slave_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length is used to constsrain the sequence length in sub-sequences </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_masters_response_ictest_sequence.html"> svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_masters_response_ictest_sequence </a> </td>
<td class="MemberListLeft" valign="center" > #- Program the Master M0 VIP to drive multiple write transactions with same ID.<br>
 #- Simultaneously program the Master M1 VIP to drive multiple write transactions<br>
 with same ID and it should be equal to ID used by M0.<br>
 #- Program the Slave VIP to respond out-of-order.<br>
 #- Program the Slave VIP to respond with OKAY for transactions addressed by M0 and<br>
 SLVERR for transactions addressed by M1. The transactions coming from M0 and M1<br>
 can be differentiated based on address.<br>
 #- Check the BRESP forwarded by interconnect to M0 are OKAY and for M1 are SLVERR.<br>
 This check will be performed within the virtual sequence running on AXI System<br>
 Sequencer.<br>
    . </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_masters_response_ictest_sequence.html#item_sequence_length">sequence_length<div>Sequence length in used to constsrain the sequence length in sub-sequences </div></a>
<br><a class="inhlist" href="class_svt_axi_ordering_write_same_id_device_non_bufferable_memory_diff_masters_response_ictest_sequence.html#item_initiating_master_index_2">initiating_master_index_2<div>Initiating second Master index </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_tlm_generic_payload_pv_sequence.html"> svt_axi_tlm_generic_payload_pv_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates UVM TLM Generic Payload Transactions.
 A WRITE transaction is followed by a READ transaction to the same address. 
 At the end constraints and write and read data is compared are checked at the PV slave side </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_tlm_generic_payload_pv_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in a sequence. </div></a>
<br> </td>
<td rowspan = 2 class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_tlm_generic_payload_sequencer.html"> svt_axi_tlm_generic_payload_sequencer </a></td> 
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_axi_tlm_generic_payload_sequence.html"> svt_axi_tlm_generic_payload_sequence </a> </td>
<td class="MemberListLeft" valign="center" > This sequence generates UVM TLM Generic Payload Transactions.
 A WRITE transaction is followed by a READ transaction to the same address. 
 At the end of the READ transaction we check that the contents of the READ
 transaction are same as the WRITE transaction  </td>
<td  valign="center" > <a class="inhlist" href="class_svt_axi_tlm_generic_payload_sequence.html#item_sequence_length">sequence_length<div>Number of Transactions in a sequence. </div></a>
<br> </td>
</tr>
<tr>
<td class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_gpio_base_sequence.html"> svt_gpio_base_sequence </a> </td>
<td class="MemberListLeft" valign="center" > Description-Unavailable </td>
<td  valign="center" >  --  </td>
<td rowspan = 1 class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_gpio_sequencer.html"> svt_gpio_sequencer </a></td> 
</tr>
<tr>
<td class="MemberListLeft" valign="center"><a class="inhlist" href="class_svt_mem_ram_sequence.html"> svt_mem_ram_sequence </a> </td>
<td class="MemberListLeft" valign="center"> Base class for all SVT mem ram sequences. 
 It is extended from svt_mem_sequence which is a reactive sequence. </td>
<td  valign="center">  --  </td>
<td rowspan = 1 class="MemberListLeft" valign="center" ><a class="inhlist" href="class_svt_mem_sequencer.html"> svt_mem_sequencer </a></td> 
</tr>
</table><br><br><hr size="1">
<address class="copyright"> 15 August 2018, Copyright &copy; 2018 Synopsys, Inc.</address>

<script src='dashboard.js'></script>
</body></html>
