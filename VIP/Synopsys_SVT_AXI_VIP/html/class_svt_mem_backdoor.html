<!DOCTYPE HTML >
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>svt_mem_backdoor Class Reference</title>
<link href="svdoc.css" rel="stylesheet" type="text/css">
<link href="svdoctabs.css" rel="stylesheet" type="text/css">
<link href="dashboard.css" rel="stylesheet" type="text/css">
<script src="advancedsearch.js"></script>
<script src="GeneralUtility.js"></script>
<script src="PCFiltering.js"></script>
</head><body>
<!-- Generated by svdoc O-2018.09 -->
<div class="tabs"><ul>
  <li><a href="index.html" TITLE = "About this product"><span>Main&nbsp;Page</span></a></li>
  <li id="current"><a href="classhierarchy.html" TITLE = "List of all classes showing the parent/child relationship"><span>Classes</span></a></li>
  <li><a href="macros.html" TITLE = "Alphabetical listing of macros"><span>Macros</span></a></li>
  <li><a href="level1_covergroups.html" TITLE = "Coverage"><span>Coverage</span></a></li>
  <li><a href="protocolChecks.html" TITLE = "List of Protocol Checks defined in VIP"><span>Protocol&nbsp;Checks</span></a></li>
  <li><a href="sequencepages.html" TITLE = "List of Sequences"><span>Sequences</span></a></li>
  <li><a href="interfaces.html" TITLE = "List of Interfaces"><span>Interfaces</span></a></li>
  <li><a href="globals.html" TITLE = "Global members"><span>Globals</span></a></li>
  <li><a href="indexall.html" TITLE = "Complete Index of all Source Code Elements"><span>Index</span></a></li>
  <li><a href="help.html" TITLE = "Help"><span>?</span></a></li>
  <li><form action="javascript:SearchFunction(form.searchtext.value, '', form.searchmode.value)"><table border="0"><tr>
    <td><input NAME="searchbtn" TYPE=button VALUE=" Search " onChange="SearchFunction(form.searchtext.value, '', form.searchmode.value)"></td>
    <td><input NAME="searchtext" TYPE=text VALUE="" onChange="SearchFunction(form.searchtext.value, '', form.searchmode.value)"></td>
    <td><select NAME="searchmode" TYPE=text >
          <option value=simple>simple</option>
          <option value=regexpr>reg expr</option>
    </select></td>
  </tr></table></form></li>
</ul></div>
<div class="tabs"><ul>
  <li><a href="classhierarchy.html" TITLE = "List of all classes showing the parent/child relationship"><span>Hierarchy</span></a></li>
  <li><a href="classlist.html" TITLE = "List of all classes"><span>Class&nbsp;List</span></a></li>
  <li><a href="classalphalist.html" TITLE = "Alphabetical listing of classes"><span>Alphabetical&nbsp;List</span></a></li>
  <li><a href="suite_classhierarchy.html" TITLE = "Suite specific list of all classes showing the parent/child relationship"><span>Transactor&nbsp;Class&nbsp;Hierarchy</span></a></li>
</ul></div>
<h1>svt_mem_backdoor Class Reference</h1>
<p>Inheritance diagram for class svt_mem_backdoor:</p>
 <input id="toggle_svt_mem_backdoor" value="+" onclick=toggleDiv("hdiv_svt_mem_backdoor","toggle_svt_mem_backdoor") title="svt_mem_backdoor class inheritence diagram" type="button"/><div id="hdiv_svt_mem_backdoor" style="display:none;"><p><center><img src="svt_mem_backdoor.png" USEMAP="#svt_mem_backdoor" border="0" alt=""> </center>
</div><map id="svt_mem_backdoor" name="svt_mem_backdoor">
<area shape="rect" id="node1" href="class_uvm_void.html" title="uvm_void" alt="" coords="52,5,129,35"/>
<area shape="rect" id="node2" href="class_uvm_object.html" title="uvm_object" alt="" coords="47,83,135,112"/>
<area shape="rect" id="node4" href="class_uvm_transaction.html" title="uvm_transaction" alt="" coords="32,160,149,189"/>
<area shape="rect" id="node6" href="class_uvm_sequence_item.html" title="uvm_sequence_item" alt="" coords="20,237,161,267"/>
<area shape="rect" id="node10" href="class_svt_mem_backdoor.html" title="svt_mem_backdoor" alt="" coords="20,393,161,423"/>
</map>
<p><a href="class_svt_mem_backdoor-members.html">List of all members.</a>
<hr>
<a name="_details"></a><h2>Detailed Description</h2>
<p>
This class provides a backdoor and iterator interface to a memory core. Multiple
 instances of this interface may exist on the same memory core.
</p>
<hr>

<table border="0" cellpadding="0" cellspacing="0">

<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_are_set">are_set</a>&nbsp;(
svt_mem_attr_t attr , svt_mem_addr_t addr   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_clear_attributes">clear_attributes</a>&nbsp;(
svt_mem_attr_t attr , svt_mem_addr_t addr   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;<a class="ClassLink" href="class_uvm_object.html#item_uvm_object">uvm_object</a>&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_clone">clone</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_compare_base">compare_base</a>&nbsp;(
string filename , svt_mem_backdoor_base :: compare_type_enum compare_type , int max_errors , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , <b>svt_mem_address_mapper</b> mapper  = null  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_copy">copy</a>&nbsp;(
<a class="ClassLink" href="class_svt_mem_backdoor.html">svt_mem_backdoor</a> rhs   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_dump_base">dump_base</a>&nbsp;(
string filename , string filetype , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , <b>svt_mem_address_mapper</b> mapper  = null, int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_free_all">free_all</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_free_attribute">free_attribute</a>&nbsp;(
svt_mem_attr_t free_attr_mask   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_free_base">free_base</a>&nbsp;(
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_access_lock_attr">get_access_lock_attr</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;svt_mem_addr_t&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_addr">get_addr</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_addr_width">get_addr_width</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;svt_mem_attr_t&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_attributes">get_attributes</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;unsigned int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_checks">get_checks</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;svt_mem_data_t&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_data">get_data</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_data_width">get_data_width</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_supported_features">get_supported_features</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;int&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_get_write_protect_attr">get_write_protect_attr</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_initialize_base">initialize_base</a>&nbsp;(
svt_mem_backdoor_base :: init_pattern_type_enum pattern  = INIT_CONST, svt_mem_data_t base_data  = 0, svt_mem_addr_t start_addr  = 0, svt_mem_addr_t end_addr  = -1, int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_load_base">load_base</a>&nbsp;(
string filename , <b>svt_mem_address_mapper</b> mapper  = null, int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_new">new</a>&nbsp;(
string name  = "", <a class="ClassLink" href="class_svt_mem_core.html">svt_mem_core</a> mem_core  = null, <a class="ClassLink" href="class_uvm_report_object.html">uvm_report_object</a> reporter  = null  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;svt_mem_attr_t&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_new_attribute">new_attribute</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_next">next</a>&nbsp;(
  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;svt_mem_attr_t&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_peek_attributes">peek_attributes</a>&nbsp;(
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_peek_base">peek_base</a>&nbsp;(
svt_mem_addr_t addr , output svt_mem_data_t data , input int modes   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_attributes">poke_attributes</a>&nbsp;(
svt_mem_attr_t attr , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_base">poke_base</a>&nbsp;(
svt_mem_addr_t addr , svt_mem_data_t data , int modes  = 0  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_protect">protect</a>&nbsp;(
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;bit&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_reset">reset</a>&nbsp;(
svt_mem_attr_t attr  = 'h2  )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_set_attributes">set_attributes</a>&nbsp;(
svt_mem_attr_t attr , svt_mem_addr_t addr   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_set_checks">set_checks</a>&nbsp;(
int unsigned enables   )</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">function&nbsp;void&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_unprotect">unprotect</a>&nbsp;(
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi   )</td>
</tr>

<tr><td colspan="2"><br><h2>Public Attributes</h2></td></tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">static const svt_mem_attr_t&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_LAST_RD">LAST_RD</a> = <a class="ClassLink" href="macros.html#item_SVT_MEM_ATTRIBUTE_LAST_RD">SVT_MEM_ATTRIBUTE_LAST_RD</a>;&nbsp;</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">static const svt_mem_attr_t&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_LAST_WR">LAST_WR</a> = <a class="ClassLink" href="macros.html#item_SVT_MEM_ATTRIBUTE_LAST_WR">SVT_MEM_ATTRIBUTE_LAST_WR</a>;&nbsp;</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">string&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_name">name</a>&nbsp;</td>
</tr>
<tr>
  <td class="MemberListLeft" nowrap align="right" valign="top">static const svt_mem_attr_t&nbsp;</td>
  <td class="MemberListRight" valign="bottom"><a class="ClassLink" href="class_svt_mem_backdoor.html#item_WRITTEN">WRITTEN</a> = <a class="ClassLink" href="macros.html#item_SVT_MEM_ATTRIBUTE_INIT">SVT_MEM_ATTRIBUTE_INIT</a>;&nbsp;</td>
</tr>
</table>
<p>
<hr>
<h2 class="pre20">Member Function Documentation</h2>
<div style="margin-left: 0px; margin->right: 0px">
<a class="anchor" name="item_are_set"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_backdoor::<b>are_set</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_attr_t attr , svt_mem_addr_t addr       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Return TRUE if the specified address exists and all of the specified
 attributes are set for the specified address.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_are_set">attr</a></b> -  attribute to test for
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_are_set">addr</a></b> -  address to test at
</div></td></tr>
</table>
<a class="anchor" name="item_clear_attributes"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_backdoor::<b>clear_attributes</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_attr_t attr , svt_mem_addr_t addr       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Clear the specified attributes for the specified address

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_clear_attributes">attr</a></b> -  attribute mask which determines which attributes to clear
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_clear_attributes">addr</a></b> -  address to modify the attribute for
</div></td></tr>
</table>
<a class="anchor" name="item_clone"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function <a class="ClassLink" href="class_uvm_object.html#item_uvm_object">uvm_object</a><br>&nbsp;svt_mem_backdoor::<b>clone</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Make a copy of this class, including the state of the iterator 
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><a class="ClassLink" href="class_uvm_object.html">uvm_object</a> <b>::</b> <a class="ClassLink" href="class_uvm_object.html#item_clone">clone</a>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_compare_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_backdoor::<b>compare_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
string filename , svt_mem_backdoor_base :: compare_type_enum compare_type , int max_errors , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , <b>svt_mem_address_mapper</b> mapper  = null      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Internal method for comparing the content of the memory in the specifed
 address range (entire memory by default) with the data found in the specifed file,
 using the relevant policy based on the filename.

<p>
 The 'mapper' can be used to convert between the source address domain used in
 the file and the destination address domain used by the backdoor. If the 'mapper'
 is not provided it implies the source and destination address domains are the
 same.

<p>
 The following comparison mode are available:

<p>

<ul><li>
 Subset: The content of the file is present in the memory core. The
 memory core may contain additional values that are ignored.

</li><li>
 Strict: The content of the file is strictly equal to the content of the
 memory core.

</li><li>
 Superset: The content of the memory core is present in the file. The
 file may contain additional values that are ignored.

</li><li>
 Intersect: The same addresses present in the memory core and in the
 file contain the same data. Addresses present only in the file or the
 memory core are ignored.

</li></ul>


<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_compare_base">filename</a></b> -  Name of the file to compare to. The file extension
 determines which format the file is created in.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_compare_base">compare_type</a></b> -  Determines which kind of compare is executed
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_compare_base">max_errors</a></b> -  Data comparison terminates after reaching max_errors. If
 max_errors is 0 assume a maximum error count of 10.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_compare_base">addr_lo</a></b> -  Starting address
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_compare_base">addr_hi</a></b> -  Ending address

<p>
 <p><b>Return values - </b>  The number of miscompares.
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>compare_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_copy"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>copy</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
<a class="ClassLink" href="class_svt_mem_backdoor.html">svt_mem_backdoor</a> rhs       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Copy the state of the specified iterator to this iterator. The specified
 iterator must refer to the same memory core.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_copy">rhs</a></b> -  svt_mem_backdoor object to be copied.
</div></td></tr>
</table>
<a class="anchor" name="item_dump_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>dump_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
string filename , string filetype , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , <b>svt_mem_address_mapper</b> mapper  = null, int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Internal method for saving memory contents within the indicated 'addr_lo' to
 'addr_hi' address range into the specified 'file' using the format identified
 by 'filetype', where the only supported values are "MIF" and "MEMH".

<p>
 The 'mapper' can be used to convert between the source address domain used in
 the file and the destination address domain used by the backdoor. If the 'mapper'
 is not provided it implies the source and destination address domains are the
 same.

<p>
 The 'modes' field is a loophole for conveying basic well defined instructions
 to the backdoor implementations.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_dump_base">filename</a></b> -  Name of the file to write to. The file extension
 determines which format the file is created in.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_dump_base">filetype</a></b> -  The string name of the format to be used when writing a
 memory dump file, either "MIF" or "MEMH".
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_dump_base">addr_lo</a></b> -  Starting address
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_dump_base">addr_hi</a></b> -  Ending address
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_dump_base">mapper</a></b> -  Used to convert between address domains.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_dump_base">modes</a></b> -  Optional dump modes, represented by individual constants. Supported values:

<ul><li>
 SVT_MEM_DUMP_ALL - Specify in order to include 'all' addresses in the output. 

</li><li>
 SVT_MEM_DUMP_NO_HEADER - To exclude the header at the front of the file.

</li><li>
 SVT_MEM_DUMP_NO_BEGIN - To exclude the BEGIN at the start of the data block (MIF).

</li><li>
 SVT_MEM_DUMP_NO_END - To exclude the END at the end of the data block (MIF).

</li><li>
 SVT_MEM_DUMP_APPEND - Append the contents to the existing file if found.

</li></ul>

</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>dump_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_free_all"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>free_all</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Free all data in the memory. 
</div></td></tr>
</table>
<a class="anchor" name="item_free_attribute"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_backdoor::<b>free_attribute</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_attr_t free_attr_mask       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Release a presviously-created user-defined attribute. The released
 attibute may be reused by a new subsequently created user-defined
 attibute.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_free_attribute">free_attr_mask</a></b> -  attributes to be freed.
</div></td></tr>
</table>
<a class="anchor" name="item_free_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_backdoor::<b>free_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Free the data associated with the specified address range, as if it had never
 been written. If addr_lo == 0 and addr_hi == -1 then this frees all of the
 data in the memory.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_free_base">addr_lo</a></b> -  Low address
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_free_base">addr_hi</a></b> -  High address
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_free_base">modes</a></b> -  Optional access modes, represented by individual constants. No
 predefined values supported.

<p>
 <p><b>Return values - </b>  Bit indicating the success (1) or failure (0) of the free operation.
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>free_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_get_access_lock_attr"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_backdoor::<b>get_access_lock_attr</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Retrieve the attribute mask for the lock attribute 
</div></td></tr>
</table>
<a class="anchor" name="item_get_addr"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function svt_mem_addr_t<br>&nbsp;svt_mem_backdoor::<b>get_addr</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Return the address of the memory location corresponding to the current
 location of the iterator.
</div></td></tr>
</table>
<a class="anchor" name="item_get_addr_width"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_backdoor::<b>get_addr_width</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Returns the configured address width of the memcore 
</div></td></tr>
</table>
<a class="anchor" name="item_get_attributes"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function svt_mem_attr_t<br>&nbsp;svt_mem_backdoor::<b>get_attributes</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Return the bitwise-OR of all attributes set for the memory location
 corresponding to the current location of the iterator
</div></td></tr>
</table>
<a class="anchor" name="item_get_checks"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function unsigned int<br>&nbsp;svt_mem_backdoor::<b>get_checks</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Retrieves the check mask which determines which checks the memserver performs 

<p>
 Retrieves the check mask which determines which checks the C-based memserver
 application performs. The return value is a bitwise-OR that determines which
 checks are enabled.

<p>
 The following macros can be used to test whether specific checks are enabled:
 <ul>
 <li>32'h00000001</li>
 <li>32'h00000002</li>
 <li>32'h00000004</li>
 <li>32'h00000008</li>
 <li>32'h00000010</li>
 <li>32'h00000020</li>
 <li>32'h00000040</li>
 <li>32'h00000080</li>
 <li>32'h00000100</li>
 <li>32'h00000200</li>
 <li>32'h00000800</li>
 </ul>
</div></td></tr>
</table>
<a class="anchor" name="item_get_data"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function svt_mem_data_t<br>&nbsp;svt_mem_backdoor::<b>get_data</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Return the value in the memory location corresponding to the current
 location of the iterator.
</div></td></tr>
</table>
<a class="anchor" name="item_get_data_width"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_backdoor::<b>get_data_width</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Returns the configured data width of the memcore 
</div></td></tr>
</table>
<a class="anchor" name="item_get_supported_features"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_backdoor::<b>get_supported_features</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Method to provide a bit vector identifying which of the common memory
 operations (i.e., currently peek, poke, load, and dump) are supported.

<p>
 This class supports all of the common memory operations, so this method
 returns a value which is an 'OR' of the following:

<ul><li>
 SVT_MEM_PEEK_OP_MASK

</li><li>
 SVT_MEM_POKE_OP_MASK

</li><li>
 SVT_MEM_LOAD_OP_MASK

</li><li>
 SVT_MEM_DUMP_OP_MASK

</li><li>
 SVT_MEM_FREE_OP_MASK

</li><li>
 SVT_MEM_INITIALIZE_OP_MASK

</li><li>
 SVT_MEM_COMPARE_OP_MASK

</li><li>
 SVT_MEM_ATTRIBUTE_OP_MASK

</li></ul>


<p>
 <p><b>Return values - </b>  Bit vector indicating which features are supported by this backdoor.
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>get_supported_features</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_get_write_protect_attr"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function int<br>&nbsp;svt_mem_backdoor::<b>get_write_protect_attr</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Retrieve the attribute mask for the write protect attribute 
</div></td></tr>
</table>
<a class="anchor" name="item_initialize_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>initialize_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_backdoor_base :: init_pattern_type_enum pattern  = INIT_CONST, svt_mem_data_t base_data  = 0, svt_mem_addr_t start_addr  = 0, svt_mem_addr_t end_addr  = -1, int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Initialize the specified address range in the memory with the specified
 pattern. Supported patterns are: constant value, incrementing values,
 decrementing values, walk left, walk right. For user-defined patterns, the
 backdoor should be used.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_initialize_base">pattern</a></b> -  initialization pattern.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_initialize_base">base_data</a></b> -  Starting data value used with each pattern
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_initialize_base">start_addr</a></b> -  start address of the region to be initialized.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_initialize_base">end_addr</a></b> -  end address of the region to be initilized.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_initialize_base">modes</a></b> -  Optional access modes, represented by individual constants. No
 predefined values supported.
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>initialize_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_load_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>load_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
string filename , <b>svt_mem_address_mapper</b> mapper  = null, int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Internal method for loading memory locations with the contents of the specified
 file.

<p>
 The 'mapper' can be used to convert between the source address domain used in the
 file and the destination address domain used by the backdoor. If the 'mapper' is
 not provided it implies the source and destination address domains are the same.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_load_base">filename</a></b> -  Name of the file to load. The file extension determines
 which format to expect.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_load_base">mapper</a></b> -  Used to convert between address domains.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_load_base">modes</a></b> -  Optional load modes, represented by individual constants. Supported values:

<ul><li>
 SVT_MEM_LOAD_WRITE_PROTECT - Marks the addresses initialized by the file as write protected

</li></ul>

</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>load_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_new"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>new</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
string name  = "", <a class="ClassLink" href="class_svt_mem_core.html">svt_mem_core</a> mem_core  = null, <a class="ClassLink" href="class_uvm_report_object.html">uvm_report_object</a> reporter  = null      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
CONSTRUCTOR: Create a new svt_mem_backdoor instance

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_new">name</a></b> -  (optional) Used to identify the backdoor in any reported messages.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_new">mem_core</a></b> -  (required) The specific mem_core that this backdoor points to.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_new">reporter</a></b> -  (optional but recommended) Used to report messages.
</div></td></tr>
</table>
<a class="anchor" name="item_new_attribute"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function svt_mem_attr_t<br>&nbsp;svt_mem_backdoor::<b>new_attribute</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Creates a new user-defined attribute that can be attanched to any address.
 Different user-defined attributes can be bitwise-OR's to operate on
 multiple attributes at the same time.

<p>
 The return value is the attribute mask for the new attribute.
</div></td></tr>
</table>
<a class="anchor" name="item_next"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_backdoor::<b>next</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Move the iterator to the next memory location. The order in which
 memory location are visited is not specified.
</div></td></tr>
</table>
<a class="anchor" name="item_peek_attributes"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function svt_mem_attr_t<br>&nbsp;svt_mem_backdoor::<b>peek_attributes</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Return the attribute settings for the indicated address range. Does an 'AND'
 or an 'OR' of the attributes within the range, based on the 'modes' setting.
 The default setting results in an 'AND' of the attributes.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_peek_attributes">addr_lo</a></b> -  Starting address.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_peek_attributes">addr_hi</a></b> -  Ending address.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_peek_attributes">modes</a></b> -  Optional attribute modes, represented by individual constants. Supported values:

<ul><li>
 SVT_MEM_ATTRIBUTE_OR - Specify to do an 'OR' of the attributes within the range. 

</li></ul>

</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>peek_attributes</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_peek_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_backdoor::<b>peek_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr , output svt_mem_data_t data , input int modes       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Set the output argument to the value found a the specified address
 Returns TRUE if a value was found. Returns FALSE otherwise. By default. the
 attributes are not modified but if specified, attributes may be set or cleared.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_peek_base">addr</a></b> -  address on which data to be read
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_peek_base">data</a></b> -  ouput data on specified address.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_peek_base">modes</a></b> -  Optional access modes, represented by individual constants. No
 predefined values supported.

<p>
 <p><b>Return values - </b>  '1' if the value was written, otherwise '0'.
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>peek_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_poke_attributes"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>poke_attributes</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_attr_t attr , svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi , int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Set the attributes for the addresses in the indicated address range. Does an
 'AND' or an 'OR' of the attributes within the range, based on the 'modes'
 setting. The default setting results in an 'AND' of the attributes.

<p>
 Special care must be taken when setting the 'access' attributes for a
 memory location as these attributes govern how the memory package interacts
 with the location.
 An access value of SVT_MEM_ATTRIBUTE_UNINIT, for example, indicates the location
 is not occupied. This will result in the failure of subsequent peek,
 peek_attribute, and poke_attribute operations of that location.

<p>
 Changing the access value between the different 'occupied' settings will not
 not result in failures with subsequent peek or poke operations. But it could
 impact the outcome of subsequent access checks which rely on these settings
 to discern the current state of the memory locations. The 'occupied' settings
 are defined by:

<ul><li>
 SVT_MEM_ATTRIBUTE_LAST_WR - Last access was a 'write' operation.

</li><li>
 SVT_MEM_ATTRIBUTE_INIT - Last access was a 'poke' or 'initialize' operation.

</li><li>
 SVT_MEM_ATTRIBUTE_LAST_RD - Last access was a 'read' operation.

</li></ul>


<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_attributes">attr</a></b> -  attribute to be set
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_attributes">addr_lo</a></b> -  Starting address.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_attributes">addr_hi</a></b> -  Ending address.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_attributes">modes</a></b> -  Optional attribute modes, represented by individual constants. Supported values:

<ul><li>
 SVT_MEM_ATTRIBUTE_OR - Specify to do an 'OR' of the attributes within the range. 

</li></ul>

</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>poke_attributes</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_poke_base"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_backdoor::<b>poke_base</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr , svt_mem_data_t data , int modes  = 0      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Write the specified value at the specified address. By default, the
 attributes are not modified but if specified, attributes may be set or 
 cleared.

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_base">addr</a></b> -  address on which data to be written
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_base">data</a></b> -  data to be written to the specific address.
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_poke_base">modes</a></b> -  Optional access modes, represented by individual constants. No
 predefined values supported.

<p>
 <p><b>Return values - </b>  '1' if the value was written, otherwise '0'.
</div></td></tr>
<tr><td>
<hr><table cellpadding="2" cellspacing="0">
<tr><td>&nbsp;Superseded functions</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td><b>svt_mem_backdoor_base</b> :: <b>poke_base</b>&nbsp;</td></tr>
</td></tr></table><p>
</table>
<a class="anchor" name="item_protect"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>protect</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Create a write protect to a memory range

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_protect">addr_lo</a></b> -  low addr address
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_protect">addr_hi</a></b> -  high addr address
</div></td></tr>
</table>
<a class="anchor" name="item_reset"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function bit<br>&nbsp;svt_mem_backdoor::<b>reset</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_attr_t attr  = 'h2      &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Reset the iterator to the first address with all the specified(bitwise-OR'd)
 attributes set. Default is SVT_MEM_ATTRIBUTE_INIT, which is interpreted to
 represent all occupied locations, whether they have been initialized or
 written to.
</div></td></tr>
</table>
<a class="anchor" name="item_set_attributes"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>set_attributes</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_attr_t attr , svt_mem_addr_t addr       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Set the specified attributes for the specified address

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_set_attributes">attr</a></b> -  attribute to be set
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_set_attributes">addr</a></b> -  address at which the attribute is updated
</div></td></tr>
</table>
<a class="anchor" name="item_set_checks"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>set_checks</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
int unsigned enables       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Sets the error checking enables which determine whether particular types of
 errors or warnings will be checked by the C-based memserver application. The
 check_enables mask uses the same bits as the status values.

<p>
 The following macros can be supplied as a bitwise-OR:
 <ul>
 <li>32'h00000001</li>
 <li>32'h00000002</li>
 <li>32'h00000004</li>
 <li>32'h00000008</li>
 <li>32'h00000010</li>
 <li>32'h00000020</li>
 <li>32'h00000040</li>
 <li>32'h00000080</li>
 <li>32'h00000100</li>
 <li>32'h00000200</li>
 <li>32'h00000800</li>
 </ul>

<p>
 Note however that not all status values represent error checks that can be
 disabled. Two pre-defined check enable defines exist:
 <ul>
 <li>(32'h00000010 | 
 32'h00000800 | 
 32'h00000040 | 
 32'h00000080 )</li>
 <ul>
 <li>includes RD_B4_WR, PARTIAL_RD, ADR_ERR, DATA_ERR</li>
 </ul>
 <li>(32'h00000001 | 
 32'h00000002 | 
 32'h00000004 | 
 32'h00000008 | 
 32'h00000010 | 
 32'h00000020 | 
 32'h00000040 | 
 32'h00000080 | 
 32'h00000100 | 
 32'h00000200 | 
 32'h00000800 | 
 32'h00004000 )</li>
 <ul>
 <li>includes all checks listed above</li>
 </ul>
 </ul>

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_set_checks">enables</a></b> -  Error check enable mask
</div></td></tr>
</table>
<a class="anchor" name="item_unprotect"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp; function void<br>&nbsp;svt_mem_backdoor::<b>unprotect</b></td>
      <td class="clmd" valign="top"><br>&nbsp;(&nbsp;
svt_mem_addr_t addr_lo , svt_mem_addr_t addr_hi       &nbsp;)&nbsp;</td>
    </tr>
    </table>
    <p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Release write protect to a memory range

<p>
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_unprotect">addr_lo</a></b> -  low addr address
 <p><b><a class="ClassLink" href="class_svt_mem_backdoor.html#item_unprotect">addr_hi</a></b> -  high addr address
</div></td></tr>
</table>
</div>
<hr>
<h2 class="pre20">Member Attribute Documentation</h2>
<div style="margin-left: 0px; margin->right: 0px">
<a class="anchor" name="item_LAST_RD"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp;static const svt_mem_attr_t&nbsp;&nbsp;attribute<br>&nbsp;svt_mem_backdoor::<b>LAST_RD</b> = <a class="ClassLink" href="macros.html#item_SVT_MEM_ATTRIBUTE_LAST_RD">SVT_MEM_ATTRIBUTE_LAST_RD</a></td>
    </tr>
    </table>
<p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Predefined attribute indicating an address was last accessed by a READ operation.
</div></td></tr>
</table>
<a class="anchor" name="item_LAST_WR"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp;static const svt_mem_attr_t&nbsp;&nbsp;attribute<br>&nbsp;svt_mem_backdoor::<b>LAST_WR</b> = <a class="ClassLink" href="macros.html#item_SVT_MEM_ATTRIBUTE_LAST_WR">SVT_MEM_ATTRIBUTE_LAST_WR</a></td>
    </tr>
    </table>
<p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Predefined attribute indicating an address was last accessed by a WRITE operation.
 Provided for backwards compatibility, but clients should actually use the
 SVT specified attribute constants.
</div></td></tr>
</table>
<a class="anchor" name="item_name"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp;string&nbsp;&nbsp;attribute<br>&nbsp;svt_mem_backdoor::<b>name</b></td>
    </tr>
    </table>
<p>
  </td>
</tr>
</table>
<a class="anchor" name="item_WRITTEN"></a>
<p>
<table class="clmdTable" cellpadding="2" cellspacing="0" width="100%">
<tr>
  <td class="clmdRow">
    <table cellpadding="0" cellspacing="0" border="0">
    <tr>
      <td class="clmd" nowrap valign="top">&nbsp;static const svt_mem_attr_t&nbsp;&nbsp;attribute<br>&nbsp;svt_mem_backdoor::<b>WRITTEN</b> = <a class="ClassLink" href="macros.html#item_SVT_MEM_ATTRIBUTE_INIT">SVT_MEM_ATTRIBUTE_INIT</a></td>
    </tr>
    </table>
<p>
  </td>
</tr>
<tr><td><hr><div style="margin-left: 10px; margin-right: 10px;">
Pre-defined attribute indicating an address has been written or initialized.
 Provided for backwards compatibility, but clients should actually use the
 SVT specified attribute constants.

<p>
 Note that this uses the SVT_MEM_ATTRIBUTE_INIT constant, although the backdoor
 code actually assumes that it represents all occupied locations, whether they
 have been initialized or written to.
</div></td></tr>
</table>
</div>
<hr size="1">
<address class="copyright"> 15 August 2018, Copyright &copy; 2018 Synopsys, Inc.</address>


<script src='dashboard.js'></script>
</body></html>
